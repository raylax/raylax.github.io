<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>raylax</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//raylax.github.io/"/>
  <updated>2021-02-23T08:59:27.339Z</updated>
  <id>https//raylax.github.io/</id>
  
  <author>
    <name>raylax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java HashMap源码之树化</title>
    <link href="https//raylax.github.io/post/java/hashmap-treeify.html"/>
    <id>https//raylax.github.io/post/java/hashmap-treeify.html</id>
    <published>2021-02-22T06:17:28.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><blockquote><p>hashmap会在hash冲突达到特定阈值之后将链表转换成红黑树</p></blockquote><h1 id="TreeNode-lt-K-V-gt"><a href="#TreeNode-lt-K-V-gt" class="headerlink" title="TreeNode&lt;K, V&gt;"></a>TreeNode&lt;K, V&gt;</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根节点设置为table相对应的位置</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算index</span></span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">            <span class="comment">// 原链表头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">            <span class="comment">// 如果原链表头结不等于根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            <span class="comment">// 后继节点</span></span><br><span class="line">                Node&lt;K,V&gt; rn;</span><br><span class="line">                <span class="comment">// 将根节点放入table</span></span><br><span class="line">                tab[index] = root;</span><br><span class="line">                <span class="comment">// root的前驱节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                <span class="comment">// 如果root存在后继节点，则将他的前驱节点设置为root的前驱节点</span></span><br><span class="line">                <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                <span class="comment">// 如果root存在前驱节点，则将他的后继节点设置为root的后继节点</span></span><br><span class="line">                <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                    rp.next = rn;</span><br><span class="line">                <span class="comment">// 如果原始节点存在</span></span><br><span class="line">                <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                    first.prev = root;</span><br><span class="line">                <span class="comment">// 将根节点的后继节点设置为原始节点</span></span><br><span class="line">                root.next = first;</span><br><span class="line">                <span class="comment">// 将根节点的前置节点设置为null</span></span><br><span class="line">                root.prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 验证红黑树准确性</span></span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="comment">// h  = hash value </span></span><br><span class="line">    <span class="comment">// k  = key </span></span><br><span class="line">    <span class="comment">// kc = key class</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>; <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph; <span class="comment">// hash值</span></span><br><span class="line">            <span class="keyword">int</span> dir; <span class="comment">// 方向</span></span><br><span class="line">            K pk; <span class="comment">// key</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left; <span class="comment">// 左子节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pr = p.right; <span class="comment">// 右子节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; q; <span class="comment">// 要找的对象</span></span><br><span class="line">            <span class="comment">// 如果当前节点的hash值大于要找的hash值则让左子节点进行下一轮查找</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="comment">// 如果当前节点的hash值小于要找的hash值则让右子节点进行下一轮查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="comment">// 如果hash值相等并且key值相等，说明找到了，直接返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="comment">// 如果hash值相等并且左子节点为空让右子节点进行下一轮查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="comment">// 如果hash值相等并且右子节点为空让左子节点进行下一轮查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="comment">// 使用comparable接口进行比较来选择向左还是右查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">            <span class="comment">// 如果comparable比较后还是相等则使用右子树进行递归查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="comment">// 如果右子树查找不到，则使用左子树进行下一轮查找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key所在的node</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个对象返回-1或1</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">             compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                 -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树化</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; </span><br><span class="line">        <span class="comment">// 遍历链表，x指向当前节点，next指向下一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果还没有根节点</span></span><br><span class="line">                x.parent = <span class="keyword">null</span>; <span class="comment">// 设置父节点为空</span></span><br><span class="line">                x.red = <span class="keyword">false</span>; <span class="comment">// 设置为黑色</span></span><br><span class="line">                root = x; <span class="comment">// 将当前节点设置为根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key; <span class="comment">// 当前节点的key</span></span><br><span class="line">                <span class="keyword">int</span> h = x.hash; <span class="comment">// 当前节点的hash</span></span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 当前key的class</span></span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 从根节点遍历</span></span><br><span class="line">                    <span class="keyword">int</span> dir; <span class="comment">// 方向</span></span><br><span class="line">                    <span class="keyword">int</span> ph; <span class="comment">// p hash</span></span><br><span class="line">                    K pk = p.key; <span class="comment">// p key</span></span><br><span class="line">                    <span class="comment">// 如果p hash大于当前节点的hash设置dir为-1表示向左插入</span></span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 如果p hash小于当前节点的hash设置dir为1表示向右插入</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 如果相等，使用comparable接口比较</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果comparable接口比较还是相等</span></span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                    <span class="comment">// 保存p节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="comment">// 如果dir小于0一定放入当前节点的左侧</span></span><br><span class="line">                    <span class="comment">// 如果dir大于0一定放入当前节点的右侧</span></span><br><span class="line">                    <span class="comment">// 如果要插入的左侧节点为null或者要插入的右侧节点为null，执行插入逻辑</span></span><br><span class="line">                    <span class="comment">// 否则将p设置为left或者right进行下一次循环</span></span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前节点的父节点设置为p</span></span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="comment">// 如果小于0，设置为左子节点</span></span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="comment">// 如果大于0，设置为右子节点</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        <span class="comment">// 执行红黑树平衡插入并且重新设置root</span></span><br><span class="line">                        root = balanceInsertion(root, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将root节点设置到table</span></span><br><span class="line">        moveRootToFront(tab, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消树化</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; hd = <span class="keyword">null</span>; <span class="comment">// 链表头</span></span><br><span class="line">        Node&lt;K,V&gt; tl = <span class="keyword">null</span>; <span class="comment">// 链表尾</span></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 将treenode转换成普通node</span></span><br><span class="line">            Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 如果链表尾没初始化将头设置为当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="comment">// 如果已经初始化将当前节点拼接到链表尾</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tl.next = p;</span><br><span class="line">            <span class="comment">// 将链表尾设置为当前节点</span></span><br><span class="line">            tl = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回链表头</span></span><br><span class="line">        <span class="keyword">return</span> hd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  map   = hashmap对象</span></span><br><span class="line"><span class="comment">     *  table = table</span></span><br><span class="line"><span class="comment">     *  h     = hash值</span></span><br><span class="line"><span class="comment">     *  k     = key</span></span><br><span class="line"><span class="comment">     *  v     = value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key class</span></span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 是否搜索过一次</span></span><br><span class="line">        <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 遍历红黑树</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> ph; <span class="comment">// hash值</span></span><br><span class="line">            <span class="keyword">int</span> dir; <span class="comment">// 方向</span></span><br><span class="line">            K pk; <span class="comment">// key</span></span><br><span class="line">            <span class="comment">// 如果当前节点hash值大于key的hash值向左查找</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                dir = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前节点hash值小于key的hash值向有查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果hash值相等并且key相等，返回当前节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="comment">// 如果hash值相等但是key不相等</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有搜索过则向左右搜索</span></span><br><span class="line">                <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                    searched = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 分别向左右查找</span></span><br><span class="line">                    <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                        <span class="comment">// 如果找到直接返回</span></span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断方向</span></span><br><span class="line">                dir = tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 保存当前节点</span></span><br><span class="line">            <span class="comment">// 如果dir所指的方向为null，说明需要创建新节点</span></span><br><span class="line">            <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; xpn = xp.next; <span class="comment">// 保存当前节点的后继节点</span></span><br><span class="line">                <span class="comment">// 创建一个新节点将当前节点的后继节点设置为新节点的后继节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                <span class="comment">// 如果向左插入将当前节点的左节点设置为新节点</span></span><br><span class="line">                <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                    xp.left = x;</span><br><span class="line">                <span class="comment">// 如果向右插入将当前节点的有节点设置为新节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    xp.right = x;</span><br><span class="line">                <span class="comment">// 将当前节点后继节点设置为新节点</span></span><br><span class="line">                xp.next = x;</span><br><span class="line">                <span class="comment">// 将新节点的父节点和前置节点设置为当前节点</span></span><br><span class="line">                x.parent = x.prev = xp;</span><br><span class="line">                <span class="comment">// 如果当前节点的后继节点不是null将当前节点的前置节点拼接到新节点</span></span><br><span class="line">                <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                <span class="comment">// 插入红黑树</span></span><br><span class="line">                moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="comment">// table长度</span></span><br><span class="line">        <span class="comment">// 如果table为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 根据hash值计算index</span></span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 头节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="comment">// 根节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; root = first;</span><br><span class="line">        <span class="comment">// 左子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; rl;</span><br><span class="line">        <span class="comment">// 当前节点的后驱节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next;</span><br><span class="line">        <span class="comment">// 当前节点的前驱结点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pred = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护双向链表</span></span><br><span class="line">        <span class="comment">// 如果前驱节点为空说明是头节点，将头节点设置为当前节点的后驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            tab[index] = first = succ;</span><br><span class="line">        <span class="comment">// 前驱节点不为空，将前驱节点的后驱节点设置为当前节点的后驱节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果后驱节点不为空，将后驱节点的前驱节点设置为当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">            succ.prev = pred;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果头节点为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果root不是根节点，重新获取根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">            root = root.root();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当以下三个条件任一满足时，当满足红黑树条件时，说明该位置元素的长度少于6（UNTREEIFY_THRESHOLD），需要对该位置元素链表化</span></span><br><span class="line"><span class="comment">         * 1. root == null 根节点为空，树节点数量为0</span></span><br><span class="line"><span class="comment">         * 2. root.right == null 右孩子为空，树节点数量最多为2</span></span><br><span class="line"><span class="comment">                 +----+                                                                                             </span></span><br><span class="line"><span class="comment">                 | 1  |                                                                                             </span></span><br><span class="line"><span class="comment">                 +----+                                                                                             </span></span><br><span class="line"><span class="comment">                   /\                                                                                               </span></span><br><span class="line"><span class="comment">                  /  \                                                                                              </span></span><br><span class="line"><span class="comment">            +-----    -----+                                                                                        </span></span><br><span class="line"><span class="comment">            | 2  |    |NULL|                                                                                        </span></span><br><span class="line"><span class="comment">            +----+    +----+</span></span><br><span class="line"><span class="comment">         * 3. (rl = root.left) == null || rl.left == null)</span></span><br><span class="line"><span class="comment">         *    (rl = root.left) == null：左孩子为空，树节点数最多为2</span></span><br><span class="line"><span class="comment">                 +----+                                                                                             </span></span><br><span class="line"><span class="comment">                 | 1  |                                                                                             </span></span><br><span class="line"><span class="comment">                 +----+                                                                                             </span></span><br><span class="line"><span class="comment">                   /\                                                                                               </span></span><br><span class="line"><span class="comment">                  /  \                                                                                              </span></span><br><span class="line"><span class="comment">            +-----    -----+                                                                                        </span></span><br><span class="line"><span class="comment">            |NULL|    |2   |                                                                                        </span></span><br><span class="line"><span class="comment">            +----+    +----+ </span></span><br><span class="line"><span class="comment">         *    rl.left == null：左孩子的左孩子为NULL，树节点数最多为6</span></span><br><span class="line"><span class="comment">                       +----+                                                                                                  </span></span><br><span class="line"><span class="comment">                       | 1  |                                                                                                  </span></span><br><span class="line"><span class="comment">                       +----+                                                                                                  </span></span><br><span class="line"><span class="comment">                        /--\                                                                                                   </span></span><br><span class="line"><span class="comment">                      /-    -\                                                                                                 </span></span><br><span class="line"><span class="comment">               +----+          +----+                                                                                          </span></span><br><span class="line"><span class="comment">               |2   |          |3   |                                                                                          </span></span><br><span class="line"><span class="comment">               +----+          +----+                                                                                          </span></span><br><span class="line"><span class="comment">                 /\              /\                                                                                            </span></span><br><span class="line"><span class="comment">                /  \            /  \                                                                                           </span></span><br><span class="line"><span class="comment">          +----+    +----++----+    +----+                                                                                     </span></span><br><span class="line"><span class="comment">          |NULL|    |4   ||5   |    |6   |                                                                                     </span></span><br><span class="line"><span class="comment">          +----+    +----++----+    +----+ </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">            || (movable</span><br><span class="line">                &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                    || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                    || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">            <span class="comment">// 链表化</span></span><br><span class="line">            tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>; <span class="comment">// 当前节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pl = left; <span class="comment">// 左子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pr = right;  <span class="comment">// 右子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; replacement;</span><br><span class="line">        <span class="comment">// 如果左右子节点都不为n空</span></span><br><span class="line">        <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找右子树的最左节点，即当前节点的后继节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">            <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                s = sl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 与当前节点交换颜色</span></span><br><span class="line">            <span class="keyword">boolean</span> c = s.red;</span><br><span class="line">            <span class="keyword">boolean</span> s.red = p.red;</span><br><span class="line">            <span class="keyword">boolean</span> p.red = c;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后继节点的右子树（后继节点肯定不存在左子树）</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">            <span class="comment">// 当前节点的父节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果右子节点等于后继节点说明当前节点只有一个右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == pr) &#123;</span><br><span class="line">                <span class="comment">// 交换两个节点</span></span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果右节点不仅只有一个</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent; <span class="comment">// 后继节点的父节点</span></span><br><span class="line">                <span class="comment">// 将当前节点的父节点设置为后继节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果后继节点是后继节点父节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                        sp.left = p; <span class="comment">// 将后继节点的左节点设置为当前节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                pl.parent = s;</span><br><span class="line">            <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                root = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = s;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = s;</span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = sr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">        <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                    pp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (movable)</span><br><span class="line">            moveRootToFront(tab, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">         * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">         * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">        <span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                            xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Recursive invariant check</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;blockquote&gt;&lt;p&gt;hashmap会在hash冲突达到特定阈值之后将链表转换成红黑树&lt;/p&gt;&lt;/block
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap源码</title>
    <link href="https//raylax.github.io/post/java/hashmap.html"/>
    <id>https//raylax.github.io/post/java/hashmap.html</id>
    <published>2021-02-21T06:17:28.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量2^4，必须为2的N次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 最大容量2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认扩容因子，当容量达到75%时进行扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 树化阈值，当链表长度&gt;=8时将链表转换成红黑树 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 链表化阈值，当红黑树节点数量&lt;=6时将红黑树转换成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 最小树化阈值，只有map容量大于此值才进行链表树化，否则直接扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 不能小于 4 * TREEIFY_THRESHOLD</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// entity集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 扩容阈值，大于阈值将进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// 容量 * 扩容因子</span></span><br><span class="line"><span class="comment">// 扩容因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 如果初始容量大于最大容量则初始容量等于最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 扩容因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点hash值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 链表下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor(int cap)"></a>tableSizeFor(int cap)</h2><p>返回大于等于输入参数且最近的2的整数次幂的数<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规定table数组的长度必须为2的n次方</span></span><br><span class="line"><span class="comment">// 2的n次方的数的特点为第n位为1其他均为0</span></span><br><span class="line"><span class="comment">// -1操作会使第1-(n-1)位全为1</span></span><br><span class="line"><span class="comment">// 假如cap的二进制位01xxxxxx</span></span><br><span class="line"><span class="comment">// 则大于等于cap且最近的2的整数次幂的数的二进制为10xxxxxx</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;    <span class="comment">// 假设n=1xxxxx</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;       <span class="comment">// n = 1xxxxx | 01xxxx = 11xxxx</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;       <span class="comment">// n = 11xxxx | 0011xx = 1111xx</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;       <span class="comment">// n = 1111xx | 000011 = 111111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;       <span class="comment">// n = 111111 | 000000 = 111111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;      <span class="comment">// n = 111111 | 000000 = 111111</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; <span class="comment">// +1得出最终的cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h1><p>向map放入key-value<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 如果key为null则hash值为0</span></span><br><span class="line">    <span class="comment">// 否则调用key的hashCode方法获取hash值</span></span><br><span class="line">    <span class="comment">// 然后与其高16位进行异或返回</span></span><br><span class="line">    <span class="comment">// 这样做的原因是当数组很短的时候只有低位参与了运算</span></span><br><span class="line">    <span class="comment">// 让高十六位特征参与运算会更好的减少散列冲突</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果是true则不改变已有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果是false则为创建模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回改变之前的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">// 局部变量table</span></span><br><span class="line">    Node&lt;K,V&gt; p; <span class="comment">// 原始node</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// table长度</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// node在table中的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断table是否等于null或者为空</span></span><br><span class="line">    <span class="comment">// 如果为空则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对hash值进行取模得到i</span></span><br><span class="line">    <span class="comment">// 当hash为2的次幂，x % hash == x &amp; (hash - 1)</span></span><br><span class="line">    <span class="comment">// 位运算效率远远高于取模运算，所以这里使用位运算代替取模</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果没有原始值，则new一个新node放入table</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; <span class="comment">// 已存在节点e</span></span><br><span class="line">        K k; <span class="comment">// 已存在节点的key</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果hash值相等并且key相等</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果p是一个红黑树则放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// hash冲突情况，遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果到链表尾，将节点添加到链表尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度大于等于阈值则进行树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果hash值相等并且key相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 设置p为当前链表节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否存在旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 改变旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果长度大于阈值则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旧容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量大于等于最大容量，将扩容阈值改为int最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新容量等于旧容量x2</span></span><br><span class="line">        <span class="comment">// 如果新容量小于最大容量，新阈值等于旧阈值*2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果旧阈值大于0，设置容量为阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 默认容量和阈值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新阈值为0计算新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置新阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 创建新table</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 当前节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果旧table里的node不为null</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将旧table的node设置为null</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果没有后继节点（即没有hash冲突）</span></span><br><span class="line">                <span class="comment">// 将当前节点放入新的table</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果当前节点是红黑树，将红黑树拆分放入新的table</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 如果有后继节点的情况（即有hash冲突）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 下一个节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 将next设置为当前节点的下一个节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 如果扩容后index在原来的位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果是初始状态，将当前节点设置为loHead</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="comment">// 如果不是初始状态，将当前节点拼接到链表上</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 设置loTail为当前节点</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果扩容后index不在原来的位置</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 同上</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将扩容后未改变index的元素复制到新数组</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将扩容后改变了index位置的元素复制到新数组</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(e.hash &amp; oldCap) == 0</code>用来判断扩容后的index是否改变<br>假设<code>capacity=8</code>、<code>threshold=6</code>，在添加第7个元素时进行扩容<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容量</span></span><br><span class="line">capacity    = <span class="number">8</span></span><br><span class="line"><span class="comment"># 扩容阈值</span></span><br><span class="line">threshold   = <span class="number">6</span></span><br><span class="line"><span class="comment"># 碰撞的index</span></span><br><span class="line">index       = <span class="number">5</span></span><br><span class="line"><span class="comment"># 碰撞的hash</span></span><br><span class="line">keys        = [<span class="number">13</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">45</span>, <span class="number">53</span>, <span class="number">61</span>]</span><br><span class="line"><span class="comment"># 根据index = hash &amp; (n - 1)</span></span><br><span class="line"><span class="comment">#    cap - 1 = 8 - 1 = 0b00001000 - 1 = 0b00000111</span></span><br><span class="line"><span class="comment"># newCap - 1 = 8 - 1 = 0b00010000 - 1 = 0b00001111</span></span><br><span class="line"><span class="comment"># 可知当cap=8时index由后3位决定，当cap=16时index由后4位决定</span></span><br><span class="line"><span class="comment"># 想要判断index是否改变仅需要判断第4位是否为1，因为0xxx &amp; 0111 == 0xxx &amp; 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hash  bin           index(cap=8)    index(cap=16)  &amp;8</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 13    0b001101      0b0101=5        0b1101=13      0b1000</span></span><br><span class="line"><span class="comment"># 21    0b010101      0b0101=5        0b0101= 5      0b0000</span></span><br><span class="line"><span class="comment"># 29    0b011101      0b0101=5        0b1101=13      0b1000</span></span><br><span class="line"><span class="comment"># 37    0b100101      0b0101=5        0b0101= 5      0b0000</span></span><br><span class="line"><span class="comment"># 45    0b101101      0b0101=5        0b1101=13      0b1000</span></span><br><span class="line"><span class="comment"># 53    0b110101      0b0101=5        0b0101= 5      0b0000</span></span><br><span class="line"><span class="comment"># 61    0b111101      0b0101=5        0b1101=13      0b1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果&amp;8不等于0，计算新index也很简单+0b1000(即旧cap)即可</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>js实现context menu</title>
    <link href="https//raylax.github.io/post/js/js-context-menu.html"/>
    <id>https//raylax.github.io/post/js/js-context-menu.html</id>
    <published>2021-02-01T13:33:43.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h1 id="各种变量解释"><a href="#各种变量解释" class="headerlink" title="各种变量解释"></a>各种变量解释</h1><ul><li>clientX<br>相对于浏览器窗口的X</li><li>clientY<br>相对于浏览器窗口的Y</li><li>offsetX<br>相对于触发事件元素的X</li><li>offsetY<br>相对于触发事件元素的Y</li><li>offsetWidth<br>元素宽度（包括边框）</li><li>offsetHeight<br>元素高度（包括边框）</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ContentMenu</span>(<span class="params">parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.menus = []</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">(<span class="params">name, handler</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.menus.push(&#123;</span><br><span class="line">            name,</span><br><span class="line">            handler,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> removeWrapper = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.wrapper) &#123;</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(<span class="keyword">this</span>.wrapper)</span><br><span class="line">            <span class="keyword">this</span>.wrapper = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> createWrapper = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>)</span><br><span class="line">        wrapper.id = <span class="string">'cm-'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">        wrapper.className = <span class="string">'cm-wrapper'</span></span><br><span class="line">        wrapper.style.opacity = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> &#123; name, handler &#125; <span class="keyword">of</span> <span class="keyword">this</span>.menus) &#123;</span><br><span class="line">            <span class="keyword">let</span> menu = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">            menu.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">                removeWrapper()</span><br><span class="line">                handler.call(<span class="keyword">this</span>.menus)</span><br><span class="line">            &#125;, <span class="literal">false</span>)</span><br><span class="line">            menu.innerText = name</span><br><span class="line">            wrapper.appendChild(menu)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    &#125;</span><br><span class="line">    parent.oncontextmenu = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> &#123; clientX, clientY, offsetX, offsetY &#125; = event</span><br><span class="line">        <span class="comment">// 创建content wrapper</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = createWrapper()</span><br><span class="line">        <span class="comment">// 因为wrapper为fixed所以可以直接设置left和top为clientX和clientY</span></span><br><span class="line">        wrapper.style.left = clientX + <span class="string">'px'</span></span><br><span class="line">        wrapper.style.top = clientY + <span class="string">'px'</span></span><br><span class="line">        <span class="comment">// 删除原有元素</span></span><br><span class="line">        removeWrapper()</span><br><span class="line">        <span class="comment">// 添加到body</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(wrapper)</span><br><span class="line">        <span class="keyword">this</span>.wrapper = wrapper</span><br><span class="line">        <span class="comment">// 处理右边界，如果元素内X偏移+本身context宽度大于元素本身宽度</span></span><br><span class="line">        <span class="keyword">if</span> (offsetX + wrapper.offsetWidth &gt; parent.offsetWidth) &#123;</span><br><span class="line">            wrapper.style.left = (clientX - wrapper.offsetWidth) + <span class="string">'px'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理下边界，如果元素内Y偏移+本身context高度大于元素本身高度</span></span><br><span class="line">        <span class="keyword">if</span> (offsetY + wrapper.offsetHeight &gt; parent.offsetHeight) &#123;</span><br><span class="line">            wrapper.style.top = (clientY - wrapper.offsetHeight) + <span class="string">'px'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为wrapper的offsetHeight只有在渲染过才能取到，所以在创建时设置成透明</span></span><br><span class="line">        <span class="comment">// 待所有属性都计算完成再显示</span></span><br><span class="line">        wrapper.style.opacity = <span class="string">'1'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cm = <span class="keyword">new</span> ContentMenu(<span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>))</span><br><span class="line">cm.add(<span class="string">'create'</span>, () =&gt; alert(<span class="string">'create'</span>))</span><br><span class="line">cm.add(<span class="string">'update'</span>, () =&gt; alert(<span class="string">'update'</span>))</span><br><span class="line">cm.add(<span class="string">'delete'</span>, () =&gt; alert(<span class="string">'delete'</span>))</span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#xxx</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">40px</span> <span class="number">30px</span> <span class="number">20px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cm-wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">margin-block</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding-inline</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cm-wrapper</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cm-wrapper</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#69c</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;各种变量解释&quot;&gt;&lt;a href=&quot;#各种变量解释&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="js/es/ts" scheme="https//raylax.github.io/categories/js-es-ts/"/>
    
    
      <category term="js" scheme="https//raylax.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js源码分析之jsfuck</title>
    <link href="https//raylax.github.io/post/js/jsfuck.html"/>
    <id>https//raylax.github.io/post/js/jsfuck.html</id>
    <published>2021-01-22T13:33:43.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><code>jsfuck</code>可以将<code>js</code>代码转换成以<code>[]()!+</code>六个字符组成的可执行代码<br>例如<code>alert(1)</code>可以转换成<code>(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]]</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>本质上基于<code>js</code>的类型转换</p><ol><li><p>数组 =&gt; booleal<br>因为数组是真值<sup>1</sup>所以使用<code>!</code>将数组转换成<code>boolean</code>类型为<code>false</code></p></li><li><p>数组 =&gt; 数字 +[N]<br>当<strong>数组长度为0</strong>或者<strong>长度为1且N为空字符串</strong>，例如<code>+[]、+[&#39;&#39;]</code>，<code>+[N]</code>的值为<code>0</code><br>当<strong>数组长度为1且N为数字是</strong>，例如<code>+[2]、+[&#39;9&#39;]</code>，<code>+[N]</code>的值为<code>N</code><br>当<strong>数组长度大于0</strong>或<strong>数组第一个元素不是上述两种情况</strong>，例如<code>+[1,2,3]、+[false]</code>，<code>+[N]</code>的值为<code>NaN</code></p></li><li><p>boolean =&gt; 数字<br><code>true/false</code>转换为数字分别为<code>1</code>和<code>0</code></p></li></ol><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>       =  ![]</span><br><span class="line"><span class="literal">true</span>        =  !![]</span><br><span class="line"><span class="literal">undefined</span>   =  [][[]] <span class="comment">// [][0] = undefined</span></span><br><span class="line"><span class="literal">NaN</span>         =  +[![]] <span class="comment">// +[false] = NaN</span></span><br><span class="line"><span class="number">0</span>           =  +[] <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span>           =  +!+[] <span class="comment">// +!+0 = +!0 = +true = 1</span></span><br><span class="line"><span class="number">2</span>           =  !+[]+!+[] <span class="comment">// !+[] + !+[] = !0 + !0 = true + true = 2</span></span><br><span class="line"><span class="number">10</span>          =  +[[+!+[]]+[+[]]] <span class="comment">// +[[1]+[0]] = +['10'] = 10</span></span><br><span class="line"><span class="built_in">Array</span>       =  []</span><br><span class="line"><span class="built_in">Number</span>      =  +[] <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">String</span>      =  []+[] <span class="comment">// "" + "" = ""</span></span><br><span class="line"><span class="built_in">Boolean</span>     =  ![] <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Function</span>    =  [][<span class="string">"filter"</span>] <span class="comment">// 数组的filter方法</span></span><br><span class="line">run         =  [][<span class="string">"filter"</span>][<span class="string">"constructor"</span>]( CODE )() <span class="comment">// 执行CODE</span></span><br><span class="line"><span class="built_in">eval</span>        =  [][<span class="string">"filter"</span>][<span class="string">"constructor"</span>](<span class="string">"return eval"</span>)()( CODE ) <span class="comment">// eval CODE</span></span><br><span class="line"><span class="built_in">window</span>      =  [][<span class="string">"filter"</span>][<span class="string">"constructor"</span>](<span class="string">"return this"</span>)() <span class="comment">// 返回window对象</span></span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><code>[][&quot;filter&quot;]</code>会获取数组的<code>filter</code>方法，<code>[][&quot;filter&quot;][&quot;constructor&quot;]</code>会返回<code>filter</code>方法的构造函数，js中所有的方法的构造函数都是<code>Function</code><sup>2</sup>对象<br><code>Function</code><sup>2</sup>的最后一个参数会被当做方法体执行所以<code>[][&quot;filter&quot;][&quot;constructor&quot;]( &quot;console.log(1)&quot; )()</code>会输出<code>1</code></p><h3 id="eval-amp-window"><a href="#eval-amp-window" class="headerlink" title="eval &amp; window"></a>eval &amp; window</h3><p><code>Function</code><sup>2</sup>执行的作用域是全局作用域所以<code>[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()</code>对于浏览器来说返回<code>window</code>，同理<code>[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return eval&quot;)()( CODE )</code>相当于返回<code>return window.eval</code>然后传递<code>CODE</code>执行</p><blockquote><p><code>[][&quot;filter&quot;]</code>中非只能是<code>filter</code>，理论上只要数组支持的函数都可以。<br>例如<code>map</code>，<code>push</code>，<code>pop</code>等都可以<br>这里使用<code>flat</code>、<code>filter</code>函数是因为其中的字母都可以从<code>true/false</code>里直接获取</p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>通过上面的分析我们就可以把代码替换成相应的<code>[]()!+</code>组合</p><p>例如官方示例<code>alert(1)</code>，可以拆解为<code>a</code>、<code>l</code>、<code>e</code>、<code>r</code>、<code>t</code>、<code>(</code>、<code>1</code>、<code>)</code></p><p>字符串和数字替换比较简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="literal">false</span>+<span class="string">""</span>)[<span class="number">1</span>]= (![]+([]+[]))[+!+[]]</span><br><span class="line">l = (<span class="literal">false</span>+<span class="string">""</span>)[<span class="number">2</span>]= (![]+([]+[]))[!+[]+!+[]]</span><br><span class="line">e = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">3</span>]= (!![]+([]+[]))[!+[]+!+[]+!+[]]</span><br><span class="line">r = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">1</span>]= (!![]+([]+[]))[+!+[]]</span><br><span class="line">t = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">0</span>]= (!![]+([]+[]))[+[]]</span><br><span class="line"><span class="number">1</span> = = +!+[]</span><br></pre></td></tr></table></figure><p>括号等特殊字符需要从<code>function</code>的<code>toString</code>里获取，例如<code>&quot;&quot; + [][&quot;flat&quot;]</code>返回<code>function flat() { [native code] }</code>，可以从中获取小括号大括号<br>第13个为小括号13可以通过拼接<code>!+[]</code>十三次实现，但是<code>&quot;flat&quot;</code>也需要替换<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flat</span></span><br><span class="line">f = (![]+([]+[]))[+[]]</span><br><span class="line">l = (![]+([]+[]))[!+[]+!+[]]</span><br><span class="line">a = (![]+([]+[]))[+!+[]]</span><br><span class="line">t = (!![]+([]+[]))[+[]]</span><br></pre></td></tr></table></figure><p></p><p>最终flat为<code>((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])</code><br>括号<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">13</span>] = ([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]</span><br><span class="line">) = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">14</span>]= ([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]</span><br></pre></td></tr></table></figure><p></p><p>组合起来<code>alert(1)</code>为<code>((![]+([]+[]))[+!+[]])+((![]+([]+[]))[!+[]+!+[]])+((!![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(+!+[])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])</code><br>我们还需要利用上面讲到的<code>[][&quot;flat&quot;][&quot;constructor&quot;]( CODE )()</code>让他运行起来<br>需要替换<code>flat</code>和<code>constructor</code>，其中很多字符已经转换过了，只需转换<code>c</code>，<code>o</code>，<code>n</code>，<code>s</code>，<code>u</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">3</span>]</span><br><span class="line">o = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">27</span>]</span><br><span class="line">n = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">19</span>]</span><br><span class="line">s = (<span class="literal">false</span>+<span class="string">""</span>)[<span class="number">3</span>]= (![]+([]+[]))[!+[]+!+[]+!+[]]</span><br><span class="line">u = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">2</span>] = (!![]+([]+[]))[!+[]+!+[]]</span><br></pre></td></tr></table></figure><p>constructor为<br><code>(([][&quot;flat&quot;]+&quot;&quot;)[3])+(([][&quot;flat&quot;]+&quot;&quot;)[27])+(([][&quot;flat&quot;]+&quot;&quot;)[19])+((false+&quot;&quot;)[3])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][&quot;flat&quot;]+&quot;&quot;)[3])+((!![]+([]+[]))[+[]])+(([][&quot;flat&quot;]+&quot;&quot;)[27])+((!![]+([]+[]))[+!+[]])</code><br>替换<code>true/false/flat</code>和数字<br><code>(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])</code></p><p>最终可执行代码为<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])][(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])](((![]+([]+[]))[+!+[]])+((![]+([]+[]))[!+[]+!+[]])+((!![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(+!+[])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]))()</span><br></pre></td></tr></table></figure><p></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">MDN 真值</a></li><li>[2] <a href="https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/function" target="_blank" rel="noopener">MDN Function</a></li><li>[3] <a href="https://github.com/aemkei/jsfuck" target="_blank" rel="noopener">jsfuck</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="js/es/ts" scheme="https//raylax.github.io/categories/js-es-ts/"/>
    
    
      <category term="js" scheme="https//raylax.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS相关代码分析-Semaphore</title>
    <link href="https//raylax.github.io/post/java/aqs-semaphore.html"/>
    <id>https//raylax.github.io/post/java/aqs-semaphore.html</id>
    <published>2021-01-20T04:06:01.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span>;</span><br><span class="line"><span class="comment">// 获取许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 释放许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基础同步器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits); <span class="comment">// 设置许可数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState(); <span class="comment">// 获取许可数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平获取共享状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState(); <span class="comment">// 获取可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 计算剩余许可数量</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining; <span class="comment">// 如果剩余数量小于0或者CAS设置剩余数量成功返回剩余数量否则自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放共享状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState(); <span class="comment">// 获取当前可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases; <span class="comment">// 计算释放后许可数量</span></span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// 检查溢出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS设置新的许可数量</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少许可数量</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState(); <span class="comment">// 获取当前可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions; <span class="comment">// 计算减少后数量</span></span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// 检查溢出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS设置减少后的数量</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果有前置等待节点直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState(); <span class="comment">// 获取可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 计算剩余许可数量</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 如果剩余许可小于0或者CAS设置成功直接返回</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>调用AQS#acquireSharedInterruptibly(int arg)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 调用对应的Sync实现的tryAcquireShared方法</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 如果小于0说明没有获取到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加到等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 如果前驱节点是头结点</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// 设置当前节点为头结点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 判断是否需要挂起</span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 挂起线程等待唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">// 清理等待队列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><p>在CountDownLatch一章有讲</p><blockquote><p>以上所有未详细解释方法在前几章已经讲过</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="AQS" scheme="https//raylax.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS相关代码分析-CountDownLatch</title>
    <link href="https//raylax.github.io/post/java/aqs-count-down-latch.html"/>
    <id>https//raylax.github.io/post/java/aqs-count-down-latch.html</id>
    <published>2021-01-17T15:06:01.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 等待（带超时时间）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">// 设置state</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p>调用AQS#releaseShared(int arg)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放共享资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    <span class="comment">// 如果全部释放完成唤醒等待队列</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果释放完了直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 减一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果CAS设置不成功自旋</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 如果等于0说明全部释放完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// unparkSuccessor相关源码在ReentrantLock已经讲过</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 如果是SIGNAL并且CAS设置初始状态成功则唤醒线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 如果是初始状态则设置状态为PROPAGATE</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// 正常调用过unparkSuccessor后其他线程会竞争改变head，如果head没变跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>调用AQS#acquireSharedInterruptibly(int arg)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程被中断，抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 如果还有待释放的state值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果全部释放返回1否则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加到共享等待队列，相关源码在ReentrantLock已经讲过</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，再次尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// &gt;=0 说明state==0 countdown结束</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置当前节点为head并向后传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)  <span class="comment">// 判断是否可以挂起线程</span></span><br><span class="line">            &amp;&amp; parkAndCheckInterrupt()) <span class="comment">// 挂起线程等待唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果失败了则取消获取</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存原始head</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 把当前节点设置为head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate &gt; 0 永远是true</span></span><br><span class="line">    <span class="comment">// 如果头节点是null或者waitStatus是有效地</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果后继节点是共享的释放共享锁</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="await-long-timeout-TimeUnit-unit"><a href="#await-long-timeout-TimeUnit-unit" class="headerlink" title="await(long timeout, TimeUnit unit)"></a>await(long timeout, TimeUnit unit)</h2><p>调用AQS#tryAcquireSharedNanos(int arg, long nanosTimeout)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 如果获取成功直接返回</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout); <span class="comment">//  超时等待</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算deadline</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 添加到等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 如果超过1000才会挂起线程，否则直接自旋</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout); <span class="comment">// 带超时挂起线程</span></span><br><span class="line">            <span class="comment">// 如果中断抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果失败了则取消获取</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>以上所有未详细解释方法在ReentrantLock一章已经讲过</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="AQS" scheme="https//raylax.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS相关代码分析-ReentrantLock</title>
    <link href="https//raylax.github.io/post/java/aqs-reentrant-lock.html"/>
    <id>https//raylax.github.io/post/java/aqs-reentrant-lock.html</id>
    <published>2021-01-12T06:17:28.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods <code>getState</code>, <code>setState</code> and <code>compareAndSetState</code> is tracked with respect to synchronization.</p></blockquote><p>AQS类是了一个实现了阻塞锁的抽象队列同步器，是<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>的基础<br>内部维护一个<code>state</code>状态值和一个<code>FIFO</code>队列</p><h1 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span>;</span><br><span class="line"><span class="comment">// CAS设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line"><span class="comment">// FIFO对列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// FIFO对列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p><code>ReentrantLock</code>是依赖<code>AQS</code>实现的一个可重入锁，我们通过分析<code>ReentrantLock</code>工作流程来分析<code>AQS</code>实现<br><code>ReentrantLock</code>中实现了公平和非公平两种形似，暂且只分析公平锁</p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p><code>lock</code>方法直接调用<code>AQS#acquire(int arg)</code>方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果获取到资源直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    <span class="comment">// 如果获取资源失败进入等待对列</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p><code>tryAcquire</code>方法由子类<code>ReentrantLock.FairSync</code>类实现<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取资源</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果状态是未锁定</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不需要排队等待则CAS设置state值</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() </span><br><span class="line">        &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 设置独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果资源已经锁定并且独占线程是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="comment">// 增加state值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 判断是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置状态值</span></span><br><span class="line">        <span class="comment">// 只有独占的同一个线程才能进入这个分支，所以这里无需使用CAS</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件都不符合说明获取失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列中是否有正在等待的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据enq方法可知，如果head和tail二者只有一个为null只有可能是head不为null，tail为null</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// h == t</span></span><br><span class="line">    <span class="comment">// h == t == null   未初始化过</span></span><br><span class="line">    <span class="comment">// h == t != null   对列中只有一个等待者</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入等待对列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 如果对列尾不为null，说明已经初始化过</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 设置新节点为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有初始化或者设置失败则进入自旋</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            <span class="comment">// 如果此时发生并发则head不为null，tail为null</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待获取</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 是否中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点则尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果获取成功则将当前节点设置成头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否需要挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            <span class="comment">// 挂起当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果失败取消获取</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前驱节点状态 0初始状态 小于0表示节点有效 大于0表示已取消</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果waitStatus已经设置好了直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果前驱节状态无效</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 依次向前查找有效节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置前驱节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 设置waitStatus信号量</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点已经不存在，直接忽略</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 清除线程</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="comment">// 循环向前寻找有效节点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// 前驱节点的下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// 设置节点为无效状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，则直接设置尾节点为当前节点前第一个有效节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    <span class="comment">// 设置前驱节点的next为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 前驱节点不是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果前驱节点等于SIGNAL或者可以设置为SIGNAL，并且前驱节点的线程不是null</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的后驱节点设置为前驱节点的后驱节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点是头节点则唤醒后驱节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒节点的后驱节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果是正常状态则设置为初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取后驱节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后驱节点不是null并且后驱节点状态无效</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部向前遍历有效节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果节点存在，唤醒节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h2><p><code>lock</code>方法直接调用<code>AQS#release(int arg)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果释放成功并且waitStatus不是初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 唤醒后驱及节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更后的state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不是锁的拥有者，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 清除独占</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置新的state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平模式"><a href="#非公平模式" class="headerlink" title="非公平模式"></a>非公平模式</h2><blockquote><p>上面讲了公平模式<code>ReentrantLock</code>也可以设置为非公平模式，主要区别在获取时并不判断当前线程是否是等待队列头</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果未锁定状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS设置状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果独占线程是当前线程，增加状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 判断溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="AQS" scheme="https//raylax.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>jvm命令行参数</title>
    <link href="https//raylax.github.io/post/jvm-command-argments.html"/>
    <id>https//raylax.github.io/post/jvm-command-argments.html</id>
    <published>2019-06-05T01:49:03.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="jvm命令行参数"><a href="#jvm命令行参数" class="headerlink" title="jvm命令行参数"></a>jvm命令行参数</h3><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><blockquote><p><strong>标准参数</strong>以<code>-</code>开头，所有jvm都实现了该参数的功能</p></blockquote><ul><li>-jar<br>指定运行一个jar包，jar包中manifest文件中必须指定Main-class</li><li>-cp<br>指定classpath路径</li><li>-Dproperty=value<br>设置系统属性键值对，使用<code>System.getProperty(&quot;property&quot;)</code>可以获得<code>value</code></li><li>-verbose<br>打印jvm载入类的相关信息</li><li>-verbose:gc<br>打印gc信息</li><li>-verbose:jni<br>打印native方法调用信息</li></ul><h4 id="非标准参数"><a href="#非标准参数" class="headerlink" title="非标准参数"></a>非标准参数</h4><blockquote><p><strong>非标准参数</strong>以<code>-X</code>开头，默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足</p></blockquote><ul><li>-Xms<br><code>-Xms1g</code> 指定jvm初始内存为1g，避免频繁扩容</li><li>-Xmx<br><code>-Xmx1g</code> 指定jvm最大可用内存为1g</li><li>-Xmn<br><code>-Xmn1g</code> 指定年轻代大小为1g，整个堆 = 年轻代 + 年老代 + 持久代，增加年轻代容量会缩小年老代容量</li><li>-Xss<br><code>-Xss1m</code> 设置线程堆栈大小，默认1m。增加此值会减少可创建的线程数量，反而能增加可创建线程数量。可创建线程数量也受操作系统限制</li><li>-Xloggc<br><code>-Xloggc:gc.log</code> 将gc日志记录到<code>gc.log</code>中</li><li>-Xprof<br>跟踪正运行的程序，并将跟踪数据在标准输出输出</li></ul><h4 id="非Stable参数"><a href="#非Stable参数" class="headerlink" title="非Stable参数"></a>非Stable参数</h4><blockquote><p><strong>非Stable参数</strong>以<code>-XX</code>开头</p></blockquote><ul><li>-XX:PermSize<br>指非堆内存初始大小</li><li>-XX:MaxPermSize<br>指对非堆内存上限</li><li>-XX:-UseSerialGC<br>使用串行GC</li><li>-XX:-UseParallelGC<br>使用并行GC</li><li>-XX:-UseConcMarkSweepGC<br>对老年代使用CMS<code>Concurrent Mark And Sweep</code> GC</li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:LargePageSizeInBytes=4m</td><td>设置用于Java堆的大页面尺寸</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>GC后java堆中空闲量占的最大比例</td></tr><tr><td>-XX:MaxNewSize=size</td><td>新生成对象能占用内存的最大值</td></tr><tr><td>-XX:MaxPermSize=64m</td><td>老生代对象能占用内存的最大值</td></tr><tr><td>-XX:MinHeapFreeRatio=40</td><td>GC后java堆中空闲量占的最小比例</td></tr><tr><td>-XX:NewRatio=2</td><td>新生代内存容量与老生代内存容量的比例</td></tr><tr><td>-XX:NewSize=2.125m</td><td>新生代对象生成时占用内存的默认值</td></tr><tr><td>-XX:ReservedCodeCacheSize=32m</td><td>保留代码占用的内存容量</td></tr><tr><td>-XX:ThreadStackSize=512</td><td>设置线程栈大小，若为0则使用系统默认值</td></tr><tr><td>-XX:+UseLargePages</td><td>使用大页面内存</td></tr><tr><td>-XX:-CITime</td><td>打印消耗在JIT编译的时间</td></tr><tr><td>-XX:ErrorFile=./hs_err_pid<pid>.log</pid></td><td>保存错误日志或者数据到文件中</td></tr><tr><td>-XX:-ExtendedDTraceProbes</td><td>开启solaris特有的dtrace探针</td></tr><tr><td>-XX:HeapDumpPath=./java_pid<pid>.hprof</pid></td><td>指定导出堆信息时的路径或文件名</td></tr><tr><td>-XX:-HeapDumpOnOutOfMemoryError</td><td>当首次遭遇OOM时导出此时堆中相关信息</td></tr><tr><td>-XX:OnError=”<cmd args="">;<cmd args="">“</cmd></cmd></td><td>出现致命ERROR之后运行自定义命令</td></tr><tr><td>-XX:OnOutOfMemoryError=”<cmd args="">;<cmd args="">“</cmd></cmd></td><td>当首次遭遇OOM时执行自定义命令</td></tr><tr><td>-XX:-PrintClassHistogram</td><td>遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同</td></tr><tr><td>-XX:-PrintConcurrentLocks</td><td>遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同</td></tr><tr><td>-XX:-PrintCommandLineFlags</td><td>打印在命令行中出现过的标记</td></tr><tr><td>-XX:-PrintCompilation</td><td>当一个方法被编译时打印相关信息</td></tr><tr><td>-XX:-PrintGC</td><td>每次GC时打印相关信息</td></tr><tr><td>-XX:-PrintGC Details</td><td>每次GC时打印详细信息</td></tr><tr><td>-XX:-PrintGCTimeStamps</td><td>打印每次GC的时间戳</td></tr><tr><td>-XX:-TraceClassLoading</td><td>跟踪类的加载信息</td></tr><tr><td>-XX:-TraceClassLoadingPreorder</td><td>跟踪被引用到的所有类的加载信息</td></tr><tr><td>-XX:-TraceClassResolution</td><td>跟踪常量池</td></tr><tr><td>-XX:-TraceClassUnloading</td><td>跟踪类的卸载信息</td></tr><tr><td>-XX:-TraceLoaderConstraints</td><td>跟踪类加载器约束的相关信息</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;jvm命令行参数&quot;&gt;&lt;a href=&quot;#jvm命令行参数&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="jvm" scheme="https//raylax.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>linux快捷键</title>
    <link href="https//raylax.github.io/post/linux-shortcut-keys.html"/>
    <id>https//raylax.github.io/post/linux-shortcut-keys.html</id>
    <published>2019-05-15T13:33:43.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + u</span><br></pre></td></tr></table></figure><blockquote><p>删除从开头到光标处的文本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + k</span><br></pre></td></tr></table></figure><blockquote><p>删除光标到结尾处的文本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + a</span><br></pre></td></tr></table></figure><blockquote><p>光标移动到命令行头</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + e</span><br></pre></td></tr></table></figure><blockquote><p>光标移动到命令行尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + f</span><br></pre></td></tr></table></figure><blockquote><p>向前移动一个单词</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w</span><br></pre></td></tr></table></figure><blockquote><p>删除一个单词</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
      <category term="linux" scheme="https//raylax.github.io/tags/linux/"/>
    
      <category term="技巧" scheme="https//raylax.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-schema与数据类型优化</title>
    <link href="https//raylax.github.io/post/mysql-schema-data-type.html"/>
    <id>https//raylax.github.io/post/mysql-schema-data-type.html</id>
    <published>2019-03-16T13:01:30.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用空间(bit)</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th></tr></thead><tbody><tr><td style="text-align:center">tinyint</td><td style="text-align:center">8</td><td style="text-align:center">-128 - 127</td><td style="text-align:center">0 - 255</td></tr><tr><td style="text-align:center">smallint</td><td style="text-align:center">16</td><td style="text-align:center">-32,768 - 32,767</td><td style="text-align:center">0 - 65,535</td></tr><tr><td style="text-align:center">mediumint</td><td style="text-align:center">24</td><td style="text-align:center">-8,388,608 - 8,388,607</td><td style="text-align:center">0 - 16,777,215</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">-2,147,483,648 - 2,147,483,647</td><td style="text-align:center">0 - 4,294,967,295</td></tr><tr><td style="text-align:center">bigint</td><td style="text-align:center">64</td><td style="text-align:center">-9,233,372,036,854,775,808 - 9,223,372,036,854,775,807</td><td style="text-align:center">0 - 18,446,744,073,709,551,615</td></tr></tbody></table><p>有符号范围为$(-2^{n-1}\sim2^{n-1}-1)$，无符号范围为$(0\sim2^{n}-1)$<br>整数类型可选<code>unsinged</code>属性，表示不能为负，该属性可以使正数范围提高一倍<br>有符号和无符号使用同样的存储空间，并且具有相同的性能<br><em>MySQL可以为整数类型指定宽度，例如<code>int(8)</code>。实际上对大多数应用并没有意义，它并不会限制类型的范围，只是规定了一些交互工具（MySQL命令行客户端）来显示字符个数的。对于存储计算来说<code>int(1)</code>和<code>int(10)</code>是一样的</em></p><h4 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h4><p>MySQL支持实数类型为<em>float</em>、<em>double</em>、<em>decimal</em><br><em>float</em>为单精度浮点类型，使用32字节来储存，<em>double</em>为双精度浮点型，使用64字节来储存<br>上述两种类型为非精确类型MySQL提供精确类型<em>decimal</em>，<em>decimal</em>类型再可以指定<code>decimal(m,n)</code>其中m为总长度n为小数长度，其占用空间为m+1<br>因为<em>decimal</em>计算需要额外的开销，所以非精确小数计算使用<em>float</em>、<em>double</em>。<br>精确计算则使用<em>int</em>类型乘小数点后$10^n$来使用<br>例如<code>123.456</code>需要精确3位，则使用<em>int</em>类型<code>123456</code>来储存，使用时直接除<code>1000</code>即可</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串分定长字符串<em>char</em>和非定长字符串<em>varchar</em><br><em>varchar</em>为可变长度字符串它的优势在于仅适用必要的空间来存储数据，但是由于可变长度更新时会比原来长，则需要额外的扩容或更换存储位置。它适合用于平均长度与最大长度差距很大的场景<br><em>char</em>为定长字符串，<em>char</em>以给定长度分配足够空间，如果需要保存的数据远远小于定义的长度则会造成空间浪费。他适合储存较短的字符串，因为定长所以不会产生内存碎片，性能高于<em>varchar</em><br><em>如何储存取决于存储引擎的实现，并非所有的引擎都会按照此方式处理，以上为通常处理方式</em></p><h3 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h3><h4 id="更小更好"><a href="#更小更好" class="headerlink" title="更小更好"></a>更小更好</h4><p>尽量选择适合业务范围的数据类型。更小的数据类型通常意味着占用更少的磁盘、内存和CPU缓存，处理时需要的占用的CPU周期更短。<br><em>字段扩容对数据库来说是一个繁重的操作，尽量避免线上对字段进行扩容</em></p><h4 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h4><p>复杂的数据类势必会占用更长的CPU周期，所以根据业务需求来选择一个相对简单的数据结构是必要的。<br>对于时间等复杂类型应选用内建数据结构来存储，而非使用字符串来存储</p><h4 id="避免NULL值"><a href="#避免NULL值" class="headerlink" title="避免NULL值"></a>避免NULL值</h4><p>如果查询中包含了可为NULL的列会使得索引、索引统计和值得比较变得更加复杂。当可为NULL的列被索引肯能需要更多的空间来索引，所以索引列尽量为非NULL列<br><em>直接将可为NULL的列改为NOT NULL可能并不能对性能带来大的提升</em></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据
      
    
    </summary>
    
      <category term="database" scheme="https//raylax.github.io/categories/database/"/>
    
    
      <category term="mysql" scheme="https//raylax.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Actor学习笔记day3-作用及消息传递</title>
    <link href="https//raylax.github.io/post/actor-learning-notes-day3.html"/>
    <id>https//raylax.github.io/post/actor-learning-notes-day3.html</id>
    <published>2019-02-13T10:36:49.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="Actor模型的作用"><a href="#Actor模型的作用" class="headerlink" title="Actor模型的作用"></a>Actor模型的作用</h3><p>Actor系统可以帮助你同时利用多个处理器的核心。为了使指定的Actor对象能够对他通过并发方式收到的消息做出回应，每个核心都会被充分利用。调度器通常被用于将线程池中的线程分配给缓存了消息的Actor对象。在繁忙的系统中消息会不断地进入Actor对象的消息缓存中，调度器会不停的为线程分配工作。一直以无阻塞的方式使用线程，可以获得理想的、高效的并发处理系统。</p><h3 id="Actor对象的消息传递"><a href="#Actor对象的消息传递" class="headerlink" title="Actor对象的消息传递"></a>Actor对象的消息传递</h3><ul><li><strong>消息通道</strong><br>消息通道指消息生产者和消息消费者的通信方式，但这种通信方式不会使消息生产者和消息消费者之间有任何联系。在使用Actor模型中，从逻辑上将消息通道就是Actor对象的消息缓存，是一种先入先出的队列。</li><li><strong>消息</strong><br>消息是构成基于消息系统的基本单位</li><li><strong>管道和过滤器</strong><br>在使用Actor模型时，使用管道和过滤器能够更从容、更轻松的解决问题</li><li><strong>消息路由器</strong><br>Actor系统中会使用各种消息路由，其中包括有状态和无状态路由、基于环境和基于上下文的路由、回环路由和基于内容路由</li><li><strong>消息译码器</strong><br>当消息进入和被送出系统时会进行各种转换，当与其他系统进行整合时很可能需要消息译码器</li><li><strong>消息端点</strong><br>端点并不是什么特殊的事物，他们仅仅是单个Actor对象</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;Actor模型的作用&quot;&gt;&lt;a href=&quot;#Actor模型的作用&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="actor" scheme="https//raylax.github.io/categories/actor/"/>
    
    
      <category term="actor" scheme="https//raylax.github.io/tags/actor/"/>
    
      <category term="scala" scheme="https//raylax.github.io/tags/scala/"/>
    
      <category term="akka" scheme="https//raylax.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Actor学习笔记day2-akka框架</title>
    <link href="https//raylax.github.io/post/actor-learning-notes-day2.html"/>
    <id>https//raylax.github.io/post/actor-learning-notes-day2.html</id>
    <published>2019-02-12T08:49:12.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="使用akka框架"><a href="#使用akka框架" class="headerlink" title="使用akka框架"></a>使用akka框架</h3><blockquote><p>环境 scala sbt<br>scala是一种运行在jvm平台的一门多范式的编程语言<br>sbt是简单构建工具(Simple build tool)的缩写，可以从官网获取<br>akka actor是typesafe(lightbend前身)公司出品的一个Actor框架</p></blockquote><p>创建<em>akka-demo</em>文件夹，创建<em>build.sbt</em>并添加以下代码<br></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"akka-demo"</span></span><br><span class="line">version := <span class="string">"0.1"</span></span><br><span class="line">scalaVersion := <span class="string">"2.12.8"</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> akkaVersion = <span class="string">"2.5.20"</span></span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">    <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % akkaVersion,</span><br><span class="line">    <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-testkit"</span> % akkaVersion,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>执行<code>sbt</code>命令等待完成</p><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inurl.akka</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorLogging</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author raylax</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params">message: <span class="type">String</span>, printerActor: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Greeter</span>._</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Printer</span>._</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">        <span class="comment">// 保存greeting</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">WhoToGreet</span>(who) =&gt;</span><br><span class="line">            greeting = message + <span class="string">", "</span> + who</span><br><span class="line">        <span class="comment">// 向printerActor发送Greeting消息</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Greet</span> =&gt;</span><br><span class="line">            printerActor ! <span class="type">Greeting</span>(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(message: <span class="type">String</span>, printerActor: <span class="type">ActorRef</span>): <span class="type">Props</span> = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">Greeter</span>(message, printerActor))</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoToGreet</span>(<span class="params">who: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Greet</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Printer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Printer</span>._</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">        <span class="comment">// 打印greeting</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Greeting</span>(greeting) =&gt;</span><br><span class="line">            log.info(<span class="string">"Greeting received (from "</span> + sender() + <span class="string">"): "</span> + greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>: <span class="type">Props</span> = <span class="type">Props</span>[<span class="type">Printer</span>]</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span>(<span class="params">greeting: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">ActorDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Greeter</span>._</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Actor系统</span></span><br><span class="line">    <span class="keyword">val</span> system: <span class="type">ActorSystem</span> = <span class="type">ActorSystem</span>(<span class="string">"helloAkka"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子Actor对象</span></span><br><span class="line">    <span class="keyword">val</span> printer: <span class="type">ActorRef</span> = </span><br><span class="line">        system.actorOf(<span class="type">Printer</span>.props, <span class="string">"printerActor"</span>)</span><br><span class="line">    <span class="keyword">val</span> howdyGreeter: <span class="type">ActorRef</span> =</span><br><span class="line">        system.actorOf(<span class="type">Greeter</span>.props(<span class="string">"Howdy"</span>, printer), <span class="string">"howdyGreeter"</span>)</span><br><span class="line">    <span class="keyword">val</span> helloGreeter: <span class="type">ActorRef</span> =</span><br><span class="line">        system.actorOf(<span class="type">Greeter</span>.props(<span class="string">"Hello"</span>, printer), <span class="string">"helloGreeter"</span>)</span><br><span class="line">    <span class="keyword">val</span> goodDayGreeter: <span class="type">ActorRef</span> =</span><br><span class="line">        system.actorOf(<span class="type">Greeter</span>.props(<span class="string">"Good day"</span>, printer), <span class="string">"goodDayGreeter"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    howdyGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Akka"</span>)</span><br><span class="line">    howdyGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">    howdyGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Lightbend"</span>)</span><br><span class="line">    howdyGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">    helloGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Scala"</span>)</span><br><span class="line">    helloGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">    goodDayGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Play"</span>)</span><br><span class="line">    goodDayGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序输出内容<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [02/12/2019 17:03:28.281] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Akka</span><br><span class="line">[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/helloGreeter#-140442030]): Hello, Scala</span><br><span class="line">[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Lightbend</span><br><span class="line">[INFO] [02/12/2019 17:03:28.297] [helloAkka-akka.actor.default-dispatcher-7] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/goodDayGreeter#1061792007]): Good day, Play</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;使用akka框架&quot;&gt;&lt;a href=&quot;#使用akka框架&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="actor" scheme="https//raylax.github.io/categories/actor/"/>
    
    
      <category term="actor" scheme="https//raylax.github.io/tags/actor/"/>
    
      <category term="scala" scheme="https//raylax.github.io/tags/scala/"/>
    
      <category term="akka" scheme="https//raylax.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Actor学习笔记day1-概述</title>
    <link href="https//raylax.github.io/post/actor-learning-notes-day1.html"/>
    <id>https//raylax.github.io/post/actor-learning-notes-day1.html</id>
    <published>2019-01-31T13:10:34.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Actor模型是一种用于处理并发计算的数学模型，他对Actor对象用作并发计算的通用基元。<br>他会对收到的消息做出处理，并且可以做以下事情：</p><ul><li>向其他Actor对象发送一定数量的消息</li><li>创建一定数量的新Actor对象</li><li>设定对下一跳消息的处理方式<br>这些操作并没有先后顺序，并且可以通过并行的方式执行他们<br>在一个Actor系统中，所有的事物都是Actor对象，只有多个Actor对象组成的系统叫做Actor系统，单个Actor对象并不能称为Actor系统。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>通过异步的方式传递消息</strong><br>如果Actor对象A1要给Actor对象A2发送消息M1，就必须知道A2的地址，那么A1就直接可以向A2发送消息。实际上A2会使用独立于A1的线程接受处理消息，A1就要以异步的方式发送消息给A2，实际上消息传输中间有一个中间对象(消息缓存单元)负责消息分发，即便如此我们还是称之为<em>异步直接传输</em></li><li><strong>状态机</strong><br>Actor支持有限状态机。当Actor对象转换为某个预设状态时，他就能改变对未来接收到的消息的处理模式。通过改变成为另一种消息处理器Actor对象就成了一种<em>有限状态机</em></li><li>*无共享**<br>一个Actor对象不会与其他Actor对象共享组件可变状态</li><li><strong>无锁处理并发</strong><br>因为Actor对象不会共享其可变状态，而且他们在同一时刻仅会接受处理一条消息，所以在对消息做出回应前Actor对象永远都不会尝试锁定他们的状态</li><li><strong>并行性</strong><br>并行性是通过将单个复杂的处理过程拆分成较小的任务以并发处理的方式执行他们实现的</li><li><strong>系统性</strong><br>单个Actor对象是不具备并行性的。Actor对象是非常轻量的，因此在在单个系统中创建多个Actor对象是推荐的处理方式。<em>任何问题都可以通过添加Actor对象来解决</em></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="actor" scheme="https//raylax.github.io/categories/actor/"/>
    
    
      <category term="actor" scheme="https//raylax.github.io/tags/actor/"/>
    
      <category term="scala" scheme="https//raylax.github.io/tags/scala/"/>
    
      <category term="akka" scheme="https//raylax.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>java-String/StringBuilder/StringBuffer区别</title>
    <link href="https//raylax.github.io/post/java/string-stringbuilder-stringbuffer.html"/>
    <id>https//raylax.github.io/post/java/string-stringbuilder-stringbuffer.html</id>
    <published>2019-01-28T14:29:04.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java.lang.String部分代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<em>String</em>是一个<em>final</em>修饰不可继承的类，内部使用<em>final</em>修饰的<em>char[]</em>来保存数据，String是不可变的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line">System.out.println((str + <span class="string">"456"</span>) == str);</span><br><span class="line"><span class="comment">// output : false</span></span><br></pre></td></tr></table></figure><p></p><p>每次对String拼接都会创建一个新String对象</p><h3 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h3><p><em>AbstractStringBuilder</em>是一个抽象类，是<em>StringBuilder</em>和<em>StringBuffer</em>的父类，二者大部分操作都是基于此类实现的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java.lang.AbstractStringBuilder部分代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><em>AbstractStringBuilder</em>是一个可变的字符串类，内部使用<em>char[]</em>来保存数据，<em>count</em>用来记录<em>value</em>已用长度。<br>每次<em>append</em>操作都会向<em>value</em>中添加数据，若数组容量不够则进行扩容，扩容后容量是原容量的2倍<br><em>append</em>操作并不会创建新对象，而是在原有对象上进行修改，所以<em>AbstractStringBuilder</em>是可变的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder bd = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(bd.append(<span class="string">"345"</span>) == bd);</span><br><span class="line"><span class="comment">// output : true</span></span><br><span class="line">StringBuffer bf = <span class="keyword">new</span> StringBuffer(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(bf.append(<span class="string">"345"</span>) == bf);</span><br><span class="line"><span class="comment">// output : true</span></span><br></pre></td></tr></table></figure><p></p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p><em>StringBuilder</em>继承<em>AbstractStringBuilder</em>类所有方法均调用父类实现</p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p><em>StringBuilder</em>继承<em>AbstractStringBuilder</em>类所有方法均调用父类实现<br>所有方法均使用<em>synchronized</em>关键字修饰，所以<em>StringBuffer</em>是线程安全的</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>实际上在编译期优化了的<code>string+</code>操作的运行效率并非低于使用其他两个类<br>因为许多编译器会将此操作优化为<code>builder.append</code>的形式<br>理论上执行效率 StringBuilder &gt; StringBuffer &gt; String</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合-List类</title>
    <link href="https//raylax.github.io/post/java/collection-list.html"/>
    <id>https//raylax.github.io/post/java/collection-list.html</id>
    <published>2019-01-27T14:47:17.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList内部使用数组实现</p><p>内部关键变量<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空列表常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认空列表常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 存放数据数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 列表大小(列表大小并不总是等于elementData.length，因为elementData会有冗余)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p></p><p>构造方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个初始容量为0空列表</span></span><br><span class="line"><span class="comment"> * 使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA填充elementData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 如果initialCapacity大于0，创建一个初始容量为initialCapacity的列表</span></span><br><span class="line"><span class="comment"> * 为elementData创建一个大小为initialCapacity的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果initialCapacity等于0，创建一个初始容量为0的数组</span></span><br><span class="line"><span class="comment"> * 使用EMPTY_ELEMENTDATA填充elementData</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果initialCapacity小于0，抛出IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 传入一个集合如果c长度不为0，将c的数组复制到elementData</span></span><br><span class="line"><span class="comment"> * c的长度赋值到size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br></pre></td></tr></table></figure><p></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>如果使用无参构造创建List，在第一次扩容时如果如果期望容量小于10则会将容量设置为10<br>后续扩容<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>也就是说每次扩容后大小是原数组大小的1.5倍</p><h4 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h4><p>ArrayList实现了<em>RandomAccess</em>接口，实际上<em>RandomAccess</em>内部并无需要实现的方法<br>此接口只是为了标识该列表支持随机访问，也就是支持按下标访问<br>主要用于<code>Collections.binarySearch</code>等方法区分查找方式</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList内部使用双向链表实现</p><p>内部关键变量<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列表大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 第一个节点指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 最后一个节点指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">// 内部Node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 实际对象</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 指向上一个对象</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 指向下一个对象</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>向头部添加对象会创建一个next指向first的新节点，将first指向新节点<br>向指定位置添加对象创建一个prev指向该位置元素的prev，last指向该对象的新节点，原对象prev指向新节点<br>向尾部添加对象会创建一个prev指向last的新节点，将last指向新节点</p><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>LinkedList实现了<em>Deque</em>接口，说明LinkedList实现了可以当做一个双向队列使用，LinkedList使用的数据结构完美的支持双向队列</p><h3 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h3><table><thead><tr><th>操作\类型</th><th style="text-align:center">ArrayList</th><th style="text-align:center">LinkedList</th></tr></thead><tbody><tr><td>获取指定位置对象</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td>向头部添加对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(1)$</td></tr><tr><td>向指定位置添加对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td>向尾部添加对象</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(1)$</td></tr><tr><td>删除头部对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(1)$</td></tr><tr><td>删除指定位置对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td>删除尾部对象</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(1)$</td></tr></tbody></table><h3 id="Vector与ArrayList区别"><a href="#Vector与ArrayList区别" class="headerlink" title="Vector与ArrayList区别"></a>Vector与ArrayList区别</h3><p><em>Vector</em>与<em>ArrayList</em>实现原理基本类似<br>主要区别在于，<em>Vector</em>每个方法都是加了<em>synchronized</em>同步的，是线程安全的<br>而<em>ArrayList</em>是非线程安全的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="集合" scheme="https//raylax.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java并发-synchronized关键字&amp;CAS锁</title>
    <link href="https//raylax.github.io/post/java/concurrent-synchronized-cas-lock.html"/>
    <id>https//raylax.github.io/post/java/concurrent-synchronized-cas-lock.html</id>
    <published>2019-01-26T11:08:29.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>java中提供了<em>synchronized</em>关键字和<em>java.util.concurrent.locks</em>包下的相关类来进行线程同步</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>在1.6之前<em>synchronized</em>是一个重量级锁，此同步方式同步成本非常高，因为阻塞线程会引起用户态和内核态之间切换。此后jvm对此同步方式进行了许多优化(偏向锁、轻量级锁)可以放心使用，而且因为是java关键字所以也可以享受以后的优化并且不需要更改代码</p><table><thead><tr><th>修饰</th><th>锁对象</th></tr></thead><tbody><tr><td>静态方法</td><td>当前类对象(class)</td></tr><tr><td>实例方法</td><td>当前实例(this)</td></tr><tr><td>修饰代码块</td><td>指定变量</td></tr></tbody></table><p><em>synchronized</em>锁膨胀过程 [偏向锁] -&gt; [轻量级锁] -&gt; [重量级锁]</p><ul><li><strong>偏向锁</strong><br>偏向锁会在第一次进行同步访问时的将访问线程的线程ID使用<em>CAS</em>记录到互斥变量的<code>Mark word</code>。<br>以后每次访问则检查访问线程的ID是否等于<em>Mark word</em>中记录的线程ID，如果等于则可以无锁同步。如果线程ID不相同则说明有其他线程竞争，此时偏向锁会膨胀成<em>轻量级锁</em><br>适用场景：自始至终仅有同一线程访问<br>优点：可以实现无锁同步<br>缺点：如果很明显有其他线程竞争则很快将膨胀成轻量级锁</li><li><strong>轻量级锁</strong><br>加锁：为访问线程创建<code>Lock record</code>，将锁对象的<code>Mark word</code>复制到<code>Lock record</code>称为<code>Displaced mark word</code>，尝试使用<em>CAS</em>将<code>Mark word</code>指向<code>Displaced mark word</code>，如果成功则获取锁成功，否则循环重试<br>解锁：使用<code>Displaced mark word</code>替换原对象的<code>Mark word</code><br>轻量级锁会在重试次数过多时膨胀成<em>重量级锁</em><br>适用场景：线程竞争少，非耗时操作<br>优点：可以避免线程阻塞造成的造成的用户态和内核态切换成本<br>缺点：如果进行耗时操作则会循环获取锁占用CPU资源</li><li><strong>重量级锁</strong><br>重量级锁会在利用操作系统底层创建互斥量实现，同步时会造成内核态切换<br>适用场景：线程竞争激烈，耗时操作<br>优点：线程直接阻塞无CPU资源占用<br>缺点：线程阻塞，阻塞和唤醒线程耗时可能会超过代码本身执行时间，性能可能低于<em>轻量级锁</em></li></ul><h3 id="ReentrantLock锁"><a href="#ReentrantLock锁" class="headerlink" title="ReentrantLock锁"></a>ReentrantLock锁</h3><p>ReentrantLock分为公平锁和非公平锁，内部使用<em>CAS</em>方式实现具体原理类似于<em>轻量级锁</em></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><strong>synchronized</strong><ol><li>java关键字，易用</li><li>无需改代码享受jdk优化</li></ol></li><li><strong>ReentrantLock</strong><ol><li>java类，加锁解锁都是实例方法，可以更灵活的控制</li><li>提供<em>Condition</em>可以灵活的控制要唤醒的线程</li><li>可以实现公平锁</li><li>可以中断等待</li></ol></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="并发" scheme="https//raylax.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发-volatile关键字</title>
    <link href="https//raylax.github.io/post/java/concurrent-volatile-keyword.html"/>
    <id>https//raylax.github.io/post/java/concurrent-volatile-keyword.html</id>
    <published>2019-01-24T06:16:31.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>前一篇文章讲了java内存模型相关概念，线程在工作的时候会从主内存中复制数据到工作内存中进行操作，这样多线程情况下就会出现数据一致性问题，使用<em>volatile</em>关键字则可以避免此问题。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果使用<em>volatile</em>关键字修饰一个类的(静态)成员变量，则有两种作用</p><ul><li>确保了多线程对此变量的可见性<br>每次获取变量会强制从主内存获取，每次修改变量后会立即刷新到主内存</li><li>禁止进行指令重排(java虚拟为了优化执行效率会进行指令重排，暂不详细说明)</li></ul><h3 id="volatile可以保证原子性么"><a href="#volatile可以保证原子性么" class="headerlink" title="volatile可以保证原子性么"></a>volatile可以保证原子性么</h3><p>volatile仅能确保每次获取的数据都是最新的数据，并不能保证原子性<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个线程增加10000</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    v.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(v.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果应该是100000，实际上这段代码运行结果并不是100000，因为<em>count++</em>操作不是一个原子操作，<em>++</em>操作会先获取<em>count</em>变量然后对其加一刷新到主内存<br>多线程情况下可能多个线程同时获取了该变量对其操作然后刷新到主内存。例如数据是5，2条线程同时获取了该变量对其+1，同时将6刷新到主内存，这时主内存的数据是6但我们期望的是7<br>要解决这个问题可以用<em>synchronized</em>和<em>ReentrantLock</em>对要操作的数据加同步锁解决此问题</p><h4 id="synchronized解决方式"><a href="#synchronized解决方式" class="headerlink" title="synchronized解决方式"></a>synchronized解决方式</h4><p>synchronized方式通过java内置字节码指令<em>monitorenter</em>和<em>monitorexit</em>实现的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object countMutex = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个线程增加10000</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (v.countMutex) &#123;</span><br><span class="line">                        v.count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(v.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><h4 id="ReentrantLock解决方式"><a href="#ReentrantLock解决方式" class="headerlink" title="ReentrantLock解决方式"></a>ReentrantLock解决方式</h4><p>ReentrantLock方式通过<em>CAS</em>方式实现<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个线程增加10000</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    v.count++;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(v.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="并发" scheme="https//raylax.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java-内存模型</title>
    <link href="https//raylax.github.io/post/java/memory-model.html"/>
    <id>https//raylax.github.io/post/java/memory-model.html</id>
    <published>2019-01-23T02:20:33.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机程序每条指令都由CPU执行，执行过程中会对数据进行操作，程序运行时的临时数据都储存在内存中。<br>但是CPU执行指令的速度远远大于内存读取/写入速度，如果每次操作都需要对内存进行一次操作会大幅度降低CPU运行速度，所以CPU引入高速缓存(L1/L2/L3)来提高读写速度，如果需要对某条数据进行操作，CPU会从内存中复制数据到高速缓存中，然后对其进行一系列操作操作，结束后刷新到内存里。<br>引入高速缓存很好的解决了CPU执行的效率问题，但引发了一致性问题，即在多核心状态下，每个核心都有自己的高速缓存，无法保证同一数据不同核心下的高速缓存是一致的。CPU通过缓存一致性协议来解决了这个问题，例如Intel MESI协议，这里不做过多说明。<br>Java虚拟机中定义了一种类似的Java内存模型，来屏蔽各硬件平台和操作系统之间的差异以及提高程序运行效率。</p><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="/img/post/jmm.jpg" alt=""></div><div class="image-caption"></div></figure><ul><li><strong>堆内存</strong><br>共享区域<br>java虚拟机管理的最大内存区域，几乎所有的对象都会在此区域分配。<br>在需要时自行扩展，可以通过<code>-Xmx|-Xms</code>来控制大小，当此区域内存回收后无法为新对象分配空间且无法扩展，则会抛出<em>OutOfMemoryError</em>异常</li><li><strong>方法区</strong><br>共享区域<br>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li><strong>栈内存</strong><br>线程私有<br>用于存储局部变量表、操作栈、动态链接、方法出口等信息。<br>该区域内存用尽会抛出<em>StackOverFlow</em>异常，常见于递归操作，可以通过<code>-Xss</code>参数来调解栈内存大小</li><li><strong>本地方法区</strong><br>线程私有<br>为Native方法服务，规范中并未明确定义数据结构和使用方式</li><li><strong>程序计数器</strong><br>线程私有<br>用于记录当前执行的字节码的行号，java虚拟机利用计数器来实现循环、跳转以及线程切换恢复执行。</li></ul><blockquote><p>使用nio分配堆外内存暂不说明</p></blockquote><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="/img/post/jmm_1.png" alt=""></div><div class="image-caption"></div></figure><p>所有对象都储存在主内存中，不包括局部变量和方法参数，局部变量与方法参数是线程私有的。<br>每个线程还有自己的工作内存，类似于CPU的高速缓存。当每个线程工作时会从主内存中拷贝一份数据到工作内存，在工作内存进行操作，操作完成后才会刷新到主内存中。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-bean管理</title>
    <link href="https//raylax.github.io/post/java/spring-bean.html"/>
    <id>https//raylax.github.io/post/java/spring-bean.html</id>
    <published>2019-01-22T10:01:56.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Spring中所有的bean都由IoC容器管理，IoC容器负责创建/销毁bean，Spring中的IoC容器即<strong>BeanFactory</strong>，<strong>BeanFactory</strong>为一个接口，Srping中所有的<strong>ApplicationContext</strong>都实现了此接口。</p></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Spring中定义了4种bean的作用域以适应不同业务场景</p><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>单例方式存在，只创建一个实例，每次获取都返回该实例(默认)</td></tr><tr><td>prototype</td><td>每次获取都创建一个新实例</td></tr><tr><td>request</td><td>同一请求下每次获取实例都返回同一个实例(仅限于WebApplicationContext)</td></tr><tr><td>session</td><td>同一会话下每次获取实例都返回同一个实例(仅限于WebApplicationContext)</td></tr></tbody></table><blockquote><p>其中后两者是只有在web环境下才生效的，基于<strong>WebApplicationContext</strong></p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><strong>singleton</strong><br>容器时启动创建，随容器关闭而销毁，可以设置<em>@Lazy</em>注解使其在第一次获取时创建</li><li><strong>prototype</strong><br>该作用域的实例Spring并不负责管理生命周期</li><li><strong>request</strong><br>随每个请求创建/销毁</li><li><strong>session</strong><br>随每个会话创建/销毁</li></ul><h3 id="生命周期监控"><a href="#生命周期监控" class="headerlink" title="生命周期监控"></a>生命周期监控</h3><blockquote><p>Spring管理的bean的生命周期可以使用一系列接口/注解来监控bean的生命周期</p></blockquote><h4 id="实例级监控"><a href="#实例级监控" class="headerlink" title="实例级监控"></a>实例级监控</h4><ul><li><strong>InitializingBean#afterPropertiesSet</strong><br>在bean初始化成功后调用</li><li><strong>DiposableBean#destroy</strong><br>在bean销毁前调用</li><li><strong>@PostConstruct</strong><br>该注解修饰的方法会在bean创建后调用</li><li><strong>@PreDestroy</strong><br>该注解修饰的方法会在bean销毁前调用<blockquote><p><code>@PostConstruct</code>修饰的方法先于<code>InitializingBean#afterPropertiesSet</code>执行<br><code>@PreDestroy</code>修饰的方法先于<code>DiposableBean#destroy</code>执行</p></blockquote></li></ul><h4 id="容器级监控"><a href="#容器级监控" class="headerlink" title="容器级监控"></a>容器级监控</h4><ul><li><strong>BeanPostProcessor#postProcessBeforeInitialization</strong><br>方法会在bean初始化前调用，先于<code>@PostConstruct|InitializingBean#afterPropertiesSet</code>执行</li><li><strong>BeanPostProcessor#postProcessAfterInitialization</strong><br>方法会在bean初始化前调用，后于<code>@PostConstruct|InitializingBean#afterPropertiesSet</code>执行</li></ul><h3 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h3><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="/img/post/spring-bean-lifecycle.jpeg" alt="上面这张图完整描述了bean的生命周期(图片来源于网络)"></div><div class="image-caption">上面这张图完整描述了bean的生命周期(图片来源于网络)</div></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="spring" scheme="https//raylax.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-事务隔离级别</title>
    <link href="https//raylax.github.io/post/mysql-transaction-isolation.html"/>
    <id>https//raylax.github.io/post/mysql-transaction-isolation.html</id>
    <published>2019-01-21T06:18:25.000Z</published>
    <updated>2021-02-23T08:59:27.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --><h3 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h3><ul><li><strong>原子性(Atomicity)</strong><br>一个事物内的所有操作视为一个不可分割的操作，事务内所有操要么全执行成功要么全失败<br>例如：一个事务内A给B转账，先从A账户中扣钱，然后向B账户中加对应的钱数，这两次数据库操作要么全成功要么全失败，不能某个操作成功了，其他的失败了</li><li><strong>一致性(Consistency)</strong><br>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少(摘自百度)<br>例如：一共有2个账户，这些账户的总余额为100，无论如何进行并发操作最终这2个账户的余额的和必须为100</li><li><strong>隔离性(Isolation)</strong><br>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作</li><li><strong>持久性(Durability)</strong><br>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><blockquote><p><strong>完全隔离</strong>是不现实的，因为完全隔离会使事务串行化，严重影响并发性能，所以引入隔离级别来控制并发访问</p></blockquote><p>MySQl支持4中隔离级别</p><table><thead><tr><th>隔离级别</th><th>描述</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td>一个事务可以读其他事务未提交的数据</td></tr><tr><td>读已提交(read committed)</td><td>一个事务只能读其他事务已提交的数据</td></tr><tr><td>可重复读(repeatable read)</td><td>一个事务内多次读同一数据必须一致(MySQL默认隔离级别)</td></tr><tr><td>串行化(serializable)</td><td>事务串行化，同一个表同时只能有一个事务进行操作</td></tr></tbody></table><h3 id="并发引发问题"><a href="#并发引发问题" class="headerlink" title="并发引发问题"></a>并发引发问题</h3><ul><li><strong>脏读</strong><br>A事务读取了B事务未提交的数据并在此基础上进行操作，结果B事务回滚了，那么A所进行的操作就是有问题的</li><li><strong>不可重复读</strong><br>不可重复读指同一事务中两次读取的数据不一致，A事务读取了一条数据，B事务修改了数据并且提交了，A事务又读了此条数据结果与上一读取的数据不一致</li><li><strong>幻读</strong><br>事务A统计了数据量，事务B添加了N条记录，事务B又查了一次，结果两次结果数量不一致</li></ul><h3 id="隔离级别对应问题"><a href="#隔离级别对应问题" class="headerlink" title="隔离级别对应问题"></a>隔离级别对应问题</h3><blockquote><p>隔离级别越往下并发效率越低，<strong>可重复读</strong>行级锁，<strong>串行化</strong>表级锁</p></blockquote><table><thead><tr><th>级别\问题</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td></tr><tr><td>读已提交(read committed)</td><td style="text-align:center">√</td><td style="text-align:center">x</td><td style="text-align:center">x</td></tr><tr><td>可重复读(repeatable read)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">x</td></tr><tr><td>串行化(serializable)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>只有<code>InnoDB</code>引擎支持事务并且支持行级锁，<code>MyISAM</code>引擎并不支持事务且仅支持表级锁<br><code>InnoDB</code>适合频繁update业务场景(交易系统)，<code>MyISAM</code>适用于大量select、insert业务场景(日志类系统)<br>处理数据库并发问题并非只能依靠数据来处理，可以结合代码进行合理的加锁，例如依靠外部<code>redis/zookeeper</code>做分布式锁</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 23 2021 09:00:29 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;事务ACID特性&quot;&gt;&lt;a href=&quot;#事务ACID特性&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="database" scheme="https//raylax.github.io/categories/database/"/>
    
    
      <category term="mysql" scheme="https//raylax.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
