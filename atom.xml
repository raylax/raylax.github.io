<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>raylax&#39;Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//raylax.github.io/"/>
  <updated>2021-01-22T09:55:41.983Z</updated>
  <id>https//raylax.github.io/</id>
  
  <author>
    <name>raylax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js源码分析之jsfuck</title>
    <link href="https//raylax.github.io/post/js/jsfuck.html"/>
    <id>https//raylax.github.io/post/js/jsfuck.html</id>
    <published>2021-01-22T13:33:43.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><code>jsfuck</code>可以将<code>js</code>代码转换成以<code>[]()!+</code>六个字符组成的可执行代码<br>例如<code>alert(1)</code>可以转换成<code>(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]]</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>本质上基于<code>js</code>的类型转换</p><ol><li><p>数组 =&gt; booleal<br>因为数组是真值<sup>1</sup>所以使用<code>!</code>将数组转换成<code>boolean</code>类型为<code>false</code></p></li><li><p>数组 =&gt; 数字 +[N]<br>当<strong>数组长度为0</strong>或者<strong>长度为1且N为空字符串</strong>，例如<code>+[]、+[&#39;&#39;]</code>，<code>+[N]</code>的值为<code>0</code><br>当<strong>数组长度为1且N为数字是</strong>，例如<code>+[2]、+[&#39;9&#39;]</code>，<code>+[N]</code>的值为<code>N</code><br>当<strong>数组长度大于0</strong>或<strong>数组第一个元素不是上述两种情况</strong>，例如<code>+[1,2,3]、+[false]</code>，<code>+[N]</code>的值为<code>NaN</code></p></li><li><p>boolean =&gt; 数字<br><code>true/false</code>转换为数字分别为<code>1</code>和<code>0</code></p></li></ol><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>       =  ![]</span><br><span class="line"><span class="literal">true</span>        =  !![]</span><br><span class="line"><span class="literal">undefined</span>   =  [][[]] <span class="comment">// [][0] = undefined</span></span><br><span class="line"><span class="literal">NaN</span>         =  +[![]] <span class="comment">// +[false] = NaN</span></span><br><span class="line"><span class="number">0</span>           =  +[] <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span>           =  +!+[] <span class="comment">// +!+0 = +!0 = +true = 1</span></span><br><span class="line"><span class="number">2</span>           =  !+[]+!+[] <span class="comment">// !+[] + !+[] = !0 + !0 = true + true = 2</span></span><br><span class="line"><span class="number">10</span>          =  +[[+!+[]]+[+[]]] <span class="comment">// +[[1]+[0]] = +['10'] = 10</span></span><br><span class="line"><span class="built_in">Array</span>       =  []</span><br><span class="line"><span class="built_in">Number</span>      =  +[] <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">String</span>      =  []+[] <span class="comment">// "" + "" = ""</span></span><br><span class="line"><span class="built_in">Boolean</span>     =  ![] <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Function</span>    =  [][<span class="string">"filter"</span>] <span class="comment">// 数组的filter方法</span></span><br><span class="line">run         =  [][<span class="string">"filter"</span>][<span class="string">"constructor"</span>]( CODE )() <span class="comment">// 执行CODE</span></span><br><span class="line"><span class="built_in">eval</span>        =  [][<span class="string">"filter"</span>][<span class="string">"constructor"</span>](<span class="string">"return eval"</span>)()( CODE ) <span class="comment">// eval CODE</span></span><br><span class="line"><span class="built_in">window</span>      =  [][<span class="string">"filter"</span>][<span class="string">"constructor"</span>](<span class="string">"return this"</span>)() <span class="comment">// 返回window对象</span></span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><code>[][&quot;filter&quot;]</code>会获取数组的<code>filter</code>方法，<code>[][&quot;filter&quot;][&quot;constructor&quot;]</code>会返回<code>filter</code>方法的构造函数，js中所有的方法的构造函数都是<code>Function</code><sup>2</sup>对象<br><code>Function</code><sup>2</sup>的最后一个参数会被当做方法体执行所以<code>[][&quot;filter&quot;][&quot;constructor&quot;]( &quot;console.log(1)&quot; )()</code>会输出<code>1</code></p><h3 id="eval-amp-window"><a href="#eval-amp-window" class="headerlink" title="eval &amp; window"></a>eval &amp; window</h3><p><code>Function</code><sup>2</sup>执行的作用域是全局作用域所以<code>[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()</code>对于浏览器来说返回<code>window</code>，同理<code>[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return eval&quot;)()( CODE )</code>相当于返回<code>return window.eval</code>然后传递<code>CODE</code>执行</p><blockquote><p><code>[][&quot;filter&quot;]</code>中非只能是<code>filter</code>，理论上只要数组支持的函数都可以。<br>例如<code>map</code>，<code>push</code>，<code>pop</code>等都可以<br>这里使用<code>flat</code>、<code>filter</code>函数是因为其中的字母都可以从<code>true/false</code>里直接获取</p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>通过上面的分析我们就可以把代码替换成相应的<code>[]()!+</code>组合</p><p>例如官方示例<code>alert(1)</code>，可以拆解为<code>a</code>、<code>l</code>、<code>e</code>、<code>r</code>、<code>t</code>、<code>(</code>、<code>1</code>、<code>)</code></p><p>字符串和数字替换比较简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="literal">false</span>+<span class="string">""</span>)[<span class="number">1</span>]= (![]+([]+[]))[+!+[]]</span><br><span class="line">l = (<span class="literal">false</span>+<span class="string">""</span>)[<span class="number">2</span>]= (![]+([]+[]))[!+[]+!+[]]</span><br><span class="line">e = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">3</span>]= (!![]+([]+[]))[!+[]+!+[]+!+[]]</span><br><span class="line">r = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">1</span>]= (!![]+([]+[]))[+!+[]]</span><br><span class="line">t = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">0</span>]= (!![]+([]+[]))[+[]]</span><br><span class="line"><span class="number">1</span> = = +!+[]</span><br></pre></td></tr></table></figure><p>括号等特殊字符需要从<code>function</code>的<code>toString</code>里获取，例如<code>&quot;&quot; + [][&quot;flat&quot;]</code>返回<code>function flat() { [native code] }</code>，可以从中获取小括号大括号<br>第13个为小括号13可以通过拼接<code>!+[]</code>十三次实现，但是<code>&quot;flat&quot;</code>也需要替换<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flat</span></span><br><span class="line">f = (![]+([]+[]))[+[]]</span><br><span class="line">l = (![]+([]+[]))[!+[]+!+[]]</span><br><span class="line">a = (![]+([]+[]))[+!+[]]</span><br><span class="line">t = (!![]+([]+[]))[+[]]</span><br></pre></td></tr></table></figure><p></p><p>最终flat为<code>((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])</code><br>括号<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">13</span>] = ([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]</span><br><span class="line">) = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">14</span>]= ([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]</span><br></pre></td></tr></table></figure><p></p><p>组合起来<code>alert(1)</code>为<code>((![]+([]+[]))[+!+[]])+((![]+([]+[]))[!+[]+!+[]])+((!![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(+!+[])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])</code><br>我们还需要利用上面讲到的<code>[][&quot;flat&quot;][&quot;constructor&quot;]( CODE )()</code>让他运行起来<br>需要替换<code>flat</code>和<code>constructor</code>，其中很多字符已经转换过了，只需转换<code>c</code>，<code>o</code>，<code>n</code>，<code>s</code>，<code>u</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">3</span>]</span><br><span class="line">o = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">27</span>]</span><br><span class="line">n = ([][<span class="string">"flat"</span>]+<span class="string">""</span>)[<span class="number">19</span>]</span><br><span class="line">s = (<span class="literal">false</span>+<span class="string">""</span>)[<span class="number">3</span>]= (![]+([]+[]))[!+[]+!+[]+!+[]]</span><br><span class="line">u = (<span class="literal">true</span>+<span class="string">""</span>)[<span class="number">2</span>] = (!![]+([]+[]))[!+[]+!+[]]</span><br></pre></td></tr></table></figure><p>constructor为<br><code>(([][&quot;flat&quot;]+&quot;&quot;)[3])+(([][&quot;flat&quot;]+&quot;&quot;)[27])+(([][&quot;flat&quot;]+&quot;&quot;)[19])+((false+&quot;&quot;)[3])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][&quot;flat&quot;]+&quot;&quot;)[3])+((!![]+([]+[]))[+[]])+(([][&quot;flat&quot;]+&quot;&quot;)[27])+((!![]+([]+[]))[+!+[]])</code><br>替换<code>true/false/flat</code>和数字<br><code>(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])</code></p><p>最终可执行代码为<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])][(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])](((![]+([]+[]))[+!+[]])+((![]+([]+[]))[!+[]+!+[]])+((!![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(+!+[])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]))()</span><br></pre></td></tr></table></figure><p></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">MDN 真值</a></li><li>[2] <a href="https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/function" target="_blank" rel="noopener">MDN Function</a></li><li>[3] <a href="https://github.com/aemkei/jsfuck" target="_blank" rel="noopener">jsfuck</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="js/es/ts" scheme="https//raylax.github.io/categories/js-es-ts/"/>
    
    
      <category term="js" scheme="https//raylax.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS相关代码分析-Semaphore</title>
    <link href="https//raylax.github.io/post/java/aqs-semaphore.html"/>
    <id>https//raylax.github.io/post/java/aqs-semaphore.html</id>
    <published>2021-01-20T04:06:01.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span>;</span><br><span class="line"><span class="comment">// 获取许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 释放许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基础同步器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits); <span class="comment">// 设置许可数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState(); <span class="comment">// 获取许可数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平获取共享状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState(); <span class="comment">// 获取可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 计算剩余许可数量</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining; <span class="comment">// 如果剩余数量小于0或者CAS设置剩余数量成功返回剩余数量否则自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放共享状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState(); <span class="comment">// 获取当前可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases; <span class="comment">// 计算释放后许可数量</span></span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// 检查溢出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS设置新的许可数量</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少许可数量</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState(); <span class="comment">// 获取当前可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions; <span class="comment">// 计算减少后数量</span></span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// 检查溢出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS设置减少后的数量</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果有前置等待节点直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState(); <span class="comment">// 获取可用许可数量</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 计算剩余许可数量</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 如果剩余许可小于0或者CAS设置成功直接返回</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>调用AQS#acquireSharedInterruptibly(int arg)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 调用对应的Sync实现的tryAcquireShared方法</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 如果小于0说明没有获取到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加到等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 如果前驱节点是头结点</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// 设置当前节点为头结点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 判断是否需要挂起</span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 挂起线程等待唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">// 清理等待队列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><p>在CountDownLatch一章有讲</p><blockquote><p>以上所有未详细解释方法在前几章已经讲过</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="AQS" scheme="https//raylax.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS相关代码分析-CountDownLatch</title>
    <link href="https//raylax.github.io/post/java/aqs-count-down-latch.html"/>
    <id>https//raylax.github.io/post/java/aqs-count-down-latch.html</id>
    <published>2021-01-17T15:06:01.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 等待（带超时时间）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">// 设置state</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p>调用AQS#releaseShared(int arg)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放共享资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    <span class="comment">// 如果全部释放完成唤醒等待队列</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果释放完了直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 减一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果CAS设置不成功自旋</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 如果等于0说明全部释放完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// unparkSuccessor相关源码在ReentrantLock已经讲过</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 如果是SIGNAL并且CAS设置初始状态成功则唤醒线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 如果是初始状态则设置状态为PROPAGATE</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// 正常调用过unparkSuccessor后其他线程会竞争改变head，如果head没变跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>调用AQS#acquireSharedInterruptibly(int arg)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程被中断，抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 如果还有待释放的state值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果全部释放返回1否则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加到共享等待队列，相关源码在ReentrantLock已经讲过</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，再次尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// &gt;=0 说明state==0 countdown结束</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置当前节点为head并向后传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)  <span class="comment">// 判断是否可以挂起线程</span></span><br><span class="line">            &amp;&amp; parkAndCheckInterrupt()) <span class="comment">// 挂起线程等待唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果失败了则取消获取</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存原始head</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 把当前节点设置为head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate &gt; 0 永远是true</span></span><br><span class="line">    <span class="comment">// 如果头节点是null或者waitStatus是有效地</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果后继节点是共享的释放共享锁</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="await-long-timeout-TimeUnit-unit"><a href="#await-long-timeout-TimeUnit-unit" class="headerlink" title="await(long timeout, TimeUnit unit)"></a>await(long timeout, TimeUnit unit)</h2><p>调用AQS#tryAcquireSharedNanos(int arg, long nanosTimeout)方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 如果获取成功直接返回</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout); <span class="comment">//  超时等待</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算deadline</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 添加到等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 如果超过1000才会挂起线程，否则直接自旋</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout); <span class="comment">// 带超时挂起线程</span></span><br><span class="line">            <span class="comment">// 如果中断抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果失败了则取消获取</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>以上所有未详细解释方法在ReentrantLock一章已经讲过</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="AQS" scheme="https//raylax.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS相关代码分析-ReentrantLock</title>
    <link href="https//raylax.github.io/post/java/aqs-reentrant-lock.html"/>
    <id>https//raylax.github.io/post/java/aqs-reentrant-lock.html</id>
    <published>2021-01-12T06:17:28.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods <code>getState</code>, <code>setState</code> and <code>compareAndSetState</code> is tracked with respect to synchronization.</p></blockquote><p>AQS类是了一个实现了阻塞锁的抽象队列同步器，是<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>的基础<br>内部维护一个<code>state</code>状态值和一个<code>FIFO</code>队列</p><h1 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span>;</span><br><span class="line"><span class="comment">// CAS设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line"><span class="comment">// FIFO对列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// FIFO对列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p><code>ReentrantLock</code>是依赖<code>AQS</code>实现的一个可重入锁，我们通过分析<code>ReentrantLock</code>工作流程来分析<code>AQS</code>实现<br><code>ReentrantLock</code>中实现了公平和非公平两种形似，暂且只分析公平锁</p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p><code>lock</code>方法直接调用<code>AQS#acquire(int arg)</code>方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果获取到资源直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    <span class="comment">// 如果获取资源失败进入等待对列</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p><code>tryAcquire</code>方法由子类<code>ReentrantLock.FairSync</code>类实现<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取资源</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果状态是未锁定</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不需要排队等待则CAS设置state值</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() </span><br><span class="line">        &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 设置独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果资源已经锁定并且独占线程是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="comment">// 增加state值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 判断是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置状态值</span></span><br><span class="line">        <span class="comment">// 只有独占的同一个线程才能进入这个分支，所以这里无需使用CAS</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件都不符合说明获取失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列中是否有正在等待的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据enq方法可知，如果head和tail二者只有一个为null只有可能是head不为null，tail为null</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// h == t</span></span><br><span class="line">    <span class="comment">// h == t == null   未初始化过</span></span><br><span class="line">    <span class="comment">// h == t != null   对列中只有一个等待者</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入等待对列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 如果对列尾不为null，说明已经初始化过</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 设置新节点为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有初始化或者设置失败则进入自旋</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            <span class="comment">// 如果此时发生并发则head不为null，tail为null</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待获取</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 是否中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点则尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果获取成功则将当前节点设置成头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否需要挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            <span class="comment">// 挂起当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果失败取消获取</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前驱节点状态 0初始状态 小于0表示节点有效 大于0表示已取消</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果waitStatus已经设置好了直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果前驱节状态无效</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 依次向前查找有效节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置前驱节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 设置waitStatus信号量</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点已经不存在，直接忽略</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 清除线程</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="comment">// 循环向前寻找有效节点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// 前驱节点的下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// 设置节点为无效状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，则直接设置尾节点为当前节点前第一个有效节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    <span class="comment">// 设置前驱节点的next为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 前驱节点不是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果前驱节点等于SIGNAL或者可以设置为SIGNAL，并且前驱节点的线程不是null</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的后驱节点设置为前驱节点的后驱节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点是头节点则唤醒后驱节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒节点的后驱节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果是正常状态则设置为初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取后驱节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后驱节点不是null并且后驱节点状态无效</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部向前遍历有效节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果节点存在，唤醒节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h2><p><code>lock</code>方法直接调用<code>AQS#release(int arg)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果释放成功并且waitStatus不是初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 唤醒后驱及节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更后的state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不是锁的拥有者，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 清除独占</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置新的state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平模式"><a href="#非公平模式" class="headerlink" title="非公平模式"></a>非公平模式</h2><blockquote><p>上面讲了公平模式<code>ReentrantLock</code>也可以设置为非公平模式，主要区别在获取时并不判断当前线程是否是等待队列头</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果未锁定状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS设置状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果独占线程是当前线程，增加状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 判断溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="AQS" scheme="https//raylax.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>jvm命令行参数</title>
    <link href="https//raylax.github.io/post/jvm-command-argments.html"/>
    <id>https//raylax.github.io/post/jvm-command-argments.html</id>
    <published>2019-06-05T01:49:03.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="jvm命令行参数"><a href="#jvm命令行参数" class="headerlink" title="jvm命令行参数"></a>jvm命令行参数</h3><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><blockquote><p><strong>标准参数</strong>以<code>-</code>开头，所有jvm都实现了该参数的功能</p></blockquote><ul><li>-jar<br>指定运行一个jar包，jar包中manifest文件中必须指定Main-class</li><li>-cp<br>指定classpath路径</li><li>-Dproperty=value<br>设置系统属性键值对，使用<code>System.getProperty(&quot;property&quot;)</code>可以获得<code>value</code></li><li>-verbose<br>打印jvm载入类的相关信息</li><li>-verbose:gc<br>打印gc信息</li><li>-verbose:jni<br>打印native方法调用信息</li></ul><h4 id="非标准参数"><a href="#非标准参数" class="headerlink" title="非标准参数"></a>非标准参数</h4><blockquote><p><strong>非标准参数</strong>以<code>-X</code>开头，默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足</p></blockquote><ul><li>-Xms<br><code>-Xms1g</code> 指定jvm初始内存为1g，避免频繁扩容</li><li>-Xmx<br><code>-Xmx1g</code> 指定jvm最大可用内存为1g</li><li>-Xmn<br><code>-Xmn1g</code> 指定年轻代大小为1g，整个堆 = 年轻代 + 年老代 + 持久代，增加年轻代容量会缩小年老代容量</li><li>-Xss<br><code>-Xss1m</code> 设置线程堆栈大小，默认1m。增加此值会减少可创建的线程数量，反而能增加可创建线程数量。可创建线程数量也受操作系统限制</li><li>-Xloggc<br><code>-Xloggc:gc.log</code> 将gc日志记录到<code>gc.log</code>中</li><li>-Xprof<br>跟踪正运行的程序，并将跟踪数据在标准输出输出</li></ul><h4 id="非Stable参数"><a href="#非Stable参数" class="headerlink" title="非Stable参数"></a>非Stable参数</h4><blockquote><p><strong>非Stable参数</strong>以<code>-XX</code>开头</p></blockquote><ul><li>-XX:PermSize<br>指非堆内存初始大小</li><li>-XX:MaxPermSize<br>指对非堆内存上限</li><li>-XX:-UseSerialGC<br>使用串行GC</li><li>-XX:-UseParallelGC<br>使用并行GC</li><li>-XX:-UseConcMarkSweepGC<br>对老年代使用CMS<code>Concurrent Mark And Sweep</code> GC</li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:LargePageSizeInBytes=4m</td><td>设置用于Java堆的大页面尺寸</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>GC后java堆中空闲量占的最大比例</td></tr><tr><td>-XX:MaxNewSize=size</td><td>新生成对象能占用内存的最大值</td></tr><tr><td>-XX:MaxPermSize=64m</td><td>老生代对象能占用内存的最大值</td></tr><tr><td>-XX:MinHeapFreeRatio=40</td><td>GC后java堆中空闲量占的最小比例</td></tr><tr><td>-XX:NewRatio=2</td><td>新生代内存容量与老生代内存容量的比例</td></tr><tr><td>-XX:NewSize=2.125m</td><td>新生代对象生成时占用内存的默认值</td></tr><tr><td>-XX:ReservedCodeCacheSize=32m</td><td>保留代码占用的内存容量</td></tr><tr><td>-XX:ThreadStackSize=512</td><td>设置线程栈大小，若为0则使用系统默认值</td></tr><tr><td>-XX:+UseLargePages</td><td>使用大页面内存</td></tr><tr><td>-XX:-CITime</td><td>打印消耗在JIT编译的时间</td></tr><tr><td>-XX:ErrorFile=./hs_err_pid<pid>.log</pid></td><td>保存错误日志或者数据到文件中</td></tr><tr><td>-XX:-ExtendedDTraceProbes</td><td>开启solaris特有的dtrace探针</td></tr><tr><td>-XX:HeapDumpPath=./java_pid<pid>.hprof</pid></td><td>指定导出堆信息时的路径或文件名</td></tr><tr><td>-XX:-HeapDumpOnOutOfMemoryError</td><td>当首次遭遇OOM时导出此时堆中相关信息</td></tr><tr><td>-XX:OnError=”<cmd args="">;<cmd args="">“</cmd></cmd></td><td>出现致命ERROR之后运行自定义命令</td></tr><tr><td>-XX:OnOutOfMemoryError=”<cmd args="">;<cmd args="">“</cmd></cmd></td><td>当首次遭遇OOM时执行自定义命令</td></tr><tr><td>-XX:-PrintClassHistogram</td><td>遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同</td></tr><tr><td>-XX:-PrintConcurrentLocks</td><td>遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同</td></tr><tr><td>-XX:-PrintCommandLineFlags</td><td>打印在命令行中出现过的标记</td></tr><tr><td>-XX:-PrintCompilation</td><td>当一个方法被编译时打印相关信息</td></tr><tr><td>-XX:-PrintGC</td><td>每次GC时打印相关信息</td></tr><tr><td>-XX:-PrintGC Details</td><td>每次GC时打印详细信息</td></tr><tr><td>-XX:-PrintGCTimeStamps</td><td>打印每次GC的时间戳</td></tr><tr><td>-XX:-TraceClassLoading</td><td>跟踪类的加载信息</td></tr><tr><td>-XX:-TraceClassLoadingPreorder</td><td>跟踪被引用到的所有类的加载信息</td></tr><tr><td>-XX:-TraceClassResolution</td><td>跟踪常量池</td></tr><tr><td>-XX:-TraceClassUnloading</td><td>跟踪类的卸载信息</td></tr><tr><td>-XX:-TraceLoaderConstraints</td><td>跟踪类加载器约束的相关信息</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;jvm命令行参数&quot;&gt;&lt;a href=&quot;#jvm命令行参数&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="jvm" scheme="https//raylax.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>linux快捷键</title>
    <link href="https//raylax.github.io/post/linux-shortcut-keys.html"/>
    <id>https//raylax.github.io/post/linux-shortcut-keys.html</id>
    <published>2019-05-15T13:33:43.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + u</span><br></pre></td></tr></table></figure><blockquote><p>删除从开头到光标处的文本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + k</span><br></pre></td></tr></table></figure><blockquote><p>删除光标到结尾处的文本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + a</span><br></pre></td></tr></table></figure><blockquote><p>光标移动到命令行头</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + e</span><br></pre></td></tr></table></figure><blockquote><p>光标移动到命令行尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + f</span><br></pre></td></tr></table></figure><blockquote><p>向前移动一个单词</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w</span><br></pre></td></tr></table></figure><blockquote><p>删除一个单词</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
      <category term="linux" scheme="https//raylax.github.io/tags/linux/"/>
    
      <category term="技巧" scheme="https//raylax.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-schema与数据类型优化</title>
    <link href="https//raylax.github.io/post/mysql-schema-data-type.html"/>
    <id>https//raylax.github.io/post/mysql-schema-data-type.html</id>
    <published>2019-03-16T13:01:30.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用空间(bit)</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th></tr></thead><tbody><tr><td style="text-align:center">tinyint</td><td style="text-align:center">8</td><td style="text-align:center">-128 - 127</td><td style="text-align:center">0 - 255</td></tr><tr><td style="text-align:center">smallint</td><td style="text-align:center">16</td><td style="text-align:center">-32,768 - 32,767</td><td style="text-align:center">0 - 65,535</td></tr><tr><td style="text-align:center">mediumint</td><td style="text-align:center">24</td><td style="text-align:center">-8,388,608 - 8,388,607</td><td style="text-align:center">0 - 16,777,215</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">-2,147,483,648 - 2,147,483,647</td><td style="text-align:center">0 - 4,294,967,295</td></tr><tr><td style="text-align:center">bigint</td><td style="text-align:center">64</td><td style="text-align:center">-9,233,372,036,854,775,808 - 9,223,372,036,854,775,807</td><td style="text-align:center">0 - 18,446,744,073,709,551,615</td></tr></tbody></table><p>有符号范围为$(-2^{n-1}\sim2^{n-1}-1)$，无符号范围为$(0\sim2^{n}-1)$<br>整数类型可选<code>unsinged</code>属性，表示不能为负，该属性可以使正数范围提高一倍<br>有符号和无符号使用同样的存储空间，并且具有相同的性能<br><em>MySQL可以为整数类型指定宽度，例如<code>int(8)</code>。实际上对大多数应用并没有意义，它并不会限制类型的范围，只是规定了一些交互工具（MySQL命令行客户端）来显示字符个数的。对于存储计算来说<code>int(1)</code>和<code>int(10)</code>是一样的</em></p><h4 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h4><p>MySQL支持实数类型为<em>float</em>、<em>double</em>、<em>decimal</em><br><em>float</em>为单精度浮点类型，使用32字节来储存，<em>double</em>为双精度浮点型，使用64字节来储存<br>上述两种类型为非精确类型MySQL提供精确类型<em>decimal</em>，<em>decimal</em>类型再可以指定<code>decimal(m,n)</code>其中m为总长度n为小数长度，其占用空间为m+1<br>因为<em>decimal</em>计算需要额外的开销，所以非精确小数计算使用<em>float</em>、<em>double</em>。<br>精确计算则使用<em>int</em>类型乘小数点后$10^n$来使用<br>例如<code>123.456</code>需要精确3位，则使用<em>int</em>类型<code>123456</code>来储存，使用时直接除<code>1000</code>即可</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串分定长字符串<em>char</em>和非定长字符串<em>varchar</em><br><em>varchar</em>为可变长度字符串它的优势在于仅适用必要的空间来存储数据，但是由于可变长度更新时会比原来长，则需要额外的扩容或更换存储位置。它适合用于平均长度与最大长度差距很大的场景<br><em>char</em>为定长字符串，<em>char</em>以给定长度分配足够空间，如果需要保存的数据远远小于定义的长度则会造成空间浪费。他适合储存较短的字符串，因为定长所以不会产生内存碎片，性能高于<em>varchar</em><br><em>如何储存取决于存储引擎的实现，并非所有的引擎都会按照此方式处理，以上为通常处理方式</em></p><h3 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h3><h4 id="更小更好"><a href="#更小更好" class="headerlink" title="更小更好"></a>更小更好</h4><p>尽量选择适合业务范围的数据类型。更小的数据类型通常意味着占用更少的磁盘、内存和CPU缓存，处理时需要的占用的CPU周期更短。<br><em>字段扩容对数据库来说是一个繁重的操作，尽量避免线上对字段进行扩容</em></p><h4 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h4><p>复杂的数据类势必会占用更长的CPU周期，所以根据业务需求来选择一个相对简单的数据结构是必要的。<br>对于时间等复杂类型应选用内建数据结构来存储，而非使用字符串来存储</p><h4 id="避免NULL值"><a href="#避免NULL值" class="headerlink" title="避免NULL值"></a>避免NULL值</h4><p>如果查询中包含了可为NULL的列会使得索引、索引统计和值得比较变得更加复杂。当可为NULL的列被索引肯能需要更多的空间来索引，所以索引列尽量为非NULL列<br><em>直接将可为NULL的列改为NOT NULL可能并不能对性能带来大的提升</em></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据
      
    
    </summary>
    
      <category term="database" scheme="https//raylax.github.io/categories/database/"/>
    
    
      <category term="mysql" scheme="https//raylax.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Actor学习笔记day3-作用及消息传递</title>
    <link href="https//raylax.github.io/post/actor-learning-notes-day3.html"/>
    <id>https//raylax.github.io/post/actor-learning-notes-day3.html</id>
    <published>2019-02-13T10:36:49.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="Actor模型的作用"><a href="#Actor模型的作用" class="headerlink" title="Actor模型的作用"></a>Actor模型的作用</h3><p>Actor系统可以帮助你同时利用多个处理器的核心。为了使指定的Actor对象能够对他通过并发方式收到的消息做出回应，每个核心都会被充分利用。调度器通常被用于将线程池中的线程分配给缓存了消息的Actor对象。在繁忙的系统中消息会不断地进入Actor对象的消息缓存中，调度器会不停的为线程分配工作。一直以无阻塞的方式使用线程，可以获得理想的、高效的并发处理系统。</p><h3 id="Actor对象的消息传递"><a href="#Actor对象的消息传递" class="headerlink" title="Actor对象的消息传递"></a>Actor对象的消息传递</h3><ul><li><strong>消息通道</strong><br>消息通道指消息生产者和消息消费者的通信方式，但这种通信方式不会使消息生产者和消息消费者之间有任何联系。在使用Actor模型中，从逻辑上将消息通道就是Actor对象的消息缓存，是一种先入先出的队列。</li><li><strong>消息</strong><br>消息是构成基于消息系统的基本单位</li><li><strong>管道和过滤器</strong><br>在使用Actor模型时，使用管道和过滤器能够更从容、更轻松的解决问题</li><li><strong>消息路由器</strong><br>Actor系统中会使用各种消息路由，其中包括有状态和无状态路由、基于环境和基于上下文的路由、回环路由和基于内容路由</li><li><strong>消息译码器</strong><br>当消息进入和被送出系统时会进行各种转换，当与其他系统进行整合时很可能需要消息译码器</li><li><strong>消息端点</strong><br>端点并不是什么特殊的事物，他们仅仅是单个Actor对象</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;Actor模型的作用&quot;&gt;&lt;a href=&quot;#Actor模型的作用&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="actor" scheme="https//raylax.github.io/categories/actor/"/>
    
    
      <category term="actor" scheme="https//raylax.github.io/tags/actor/"/>
    
      <category term="scala" scheme="https//raylax.github.io/tags/scala/"/>
    
      <category term="akka" scheme="https//raylax.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Actor学习笔记day2-akka框架</title>
    <link href="https//raylax.github.io/post/actor-learning-notes-day2.html"/>
    <id>https//raylax.github.io/post/actor-learning-notes-day2.html</id>
    <published>2019-02-12T08:49:12.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="使用akka框架"><a href="#使用akka框架" class="headerlink" title="使用akka框架"></a>使用akka框架</h3><blockquote><p>环境 scala sbt<br>scala是一种运行在jvm平台的一门多范式的编程语言<br>sbt是简单构建工具(Simple build tool)的缩写，可以从官网获取<br>akka actor是typesafe(lightbend前身)公司出品的一个Actor框架</p></blockquote><p>创建<em>akka-demo</em>文件夹，创建<em>build.sbt</em>并添加以下代码<br></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"akka-demo"</span></span><br><span class="line">version := <span class="string">"0.1"</span></span><br><span class="line">scalaVersion := <span class="string">"2.12.8"</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> akkaVersion = <span class="string">"2.5.20"</span></span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">    <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % akkaVersion,</span><br><span class="line">    <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-testkit"</span> % akkaVersion,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>执行<code>sbt</code>命令等待完成</p><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inurl.akka</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorLogging</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author raylax</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params">message: <span class="type">String</span>, printerActor: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Greeter</span>._</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Printer</span>._</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">        <span class="comment">// 保存greeting</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">WhoToGreet</span>(who) =&gt;</span><br><span class="line">            greeting = message + <span class="string">", "</span> + who</span><br><span class="line">        <span class="comment">// 向printerActor发送Greeting消息</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Greet</span> =&gt;</span><br><span class="line">            printerActor ! <span class="type">Greeting</span>(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(message: <span class="type">String</span>, printerActor: <span class="type">ActorRef</span>): <span class="type">Props</span> = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">Greeter</span>(message, printerActor))</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoToGreet</span>(<span class="params">who: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Greet</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Printer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Printer</span>._</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">        <span class="comment">// 打印greeting</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Greeting</span>(greeting) =&gt;</span><br><span class="line">            log.info(<span class="string">"Greeting received (from "</span> + sender() + <span class="string">"): "</span> + greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>: <span class="type">Props</span> = <span class="type">Props</span>[<span class="type">Printer</span>]</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span>(<span class="params">greeting: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">ActorDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">Greeter</span>._</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Actor系统</span></span><br><span class="line">    <span class="keyword">val</span> system: <span class="type">ActorSystem</span> = <span class="type">ActorSystem</span>(<span class="string">"helloAkka"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子Actor对象</span></span><br><span class="line">    <span class="keyword">val</span> printer: <span class="type">ActorRef</span> = </span><br><span class="line">        system.actorOf(<span class="type">Printer</span>.props, <span class="string">"printerActor"</span>)</span><br><span class="line">    <span class="keyword">val</span> howdyGreeter: <span class="type">ActorRef</span> =</span><br><span class="line">        system.actorOf(<span class="type">Greeter</span>.props(<span class="string">"Howdy"</span>, printer), <span class="string">"howdyGreeter"</span>)</span><br><span class="line">    <span class="keyword">val</span> helloGreeter: <span class="type">ActorRef</span> =</span><br><span class="line">        system.actorOf(<span class="type">Greeter</span>.props(<span class="string">"Hello"</span>, printer), <span class="string">"helloGreeter"</span>)</span><br><span class="line">    <span class="keyword">val</span> goodDayGreeter: <span class="type">ActorRef</span> =</span><br><span class="line">        system.actorOf(<span class="type">Greeter</span>.props(<span class="string">"Good day"</span>, printer), <span class="string">"goodDayGreeter"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    howdyGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Akka"</span>)</span><br><span class="line">    howdyGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">    howdyGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Lightbend"</span>)</span><br><span class="line">    howdyGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">    helloGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Scala"</span>)</span><br><span class="line">    helloGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">    goodDayGreeter ! <span class="type">WhoToGreet</span>(<span class="string">"Play"</span>)</span><br><span class="line">    goodDayGreeter ! <span class="type">Greet</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序输出内容<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [02/12/2019 17:03:28.281] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Akka</span><br><span class="line">[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/helloGreeter#-140442030]): Hello, Scala</span><br><span class="line">[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Lightbend</span><br><span class="line">[INFO] [02/12/2019 17:03:28.297] [helloAkka-akka.actor.default-dispatcher-7] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/goodDayGreeter#1061792007]): Good day, Play</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;使用akka框架&quot;&gt;&lt;a href=&quot;#使用akka框架&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="actor" scheme="https//raylax.github.io/categories/actor/"/>
    
    
      <category term="actor" scheme="https//raylax.github.io/tags/actor/"/>
    
      <category term="scala" scheme="https//raylax.github.io/tags/scala/"/>
    
      <category term="akka" scheme="https//raylax.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Actor学习笔记day1-概述</title>
    <link href="https//raylax.github.io/post/actor-learning-notes-day1.html"/>
    <id>https//raylax.github.io/post/actor-learning-notes-day1.html</id>
    <published>2019-01-31T13:10:34.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Actor模型是一种用于处理并发计算的数学模型，他对Actor对象用作并发计算的通用基元。<br>他会对收到的消息做出处理，并且可以做以下事情：</p><ul><li>向其他Actor对象发送一定数量的消息</li><li>创建一定数量的新Actor对象</li><li>设定对下一跳消息的处理方式<br>这些操作并没有先后顺序，并且可以通过并行的方式执行他们<br>在一个Actor系统中，所有的事物都是Actor对象，只有多个Actor对象组成的系统叫做Actor系统，单个Actor对象并不能称为Actor系统。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>通过异步的方式传递消息</strong><br>如果Actor对象A1要给Actor对象A2发送消息M1，就必须知道A2的地址，那么A1就直接可以向A2发送消息。实际上A2会使用独立于A1的线程接受处理消息，A1就要以异步的方式发送消息给A2，实际上消息传输中间有一个中间对象(消息缓存单元)负责消息分发，即便如此我们还是称之为<em>异步直接传输</em></li><li><strong>状态机</strong><br>Actor支持有限状态机。当Actor对象转换为某个预设状态时，他就能改变对未来接收到的消息的处理模式。通过改变成为另一种消息处理器Actor对象就成了一种<em>有限状态机</em></li><li>*无共享**<br>一个Actor对象不会与其他Actor对象共享组件可变状态</li><li><strong>无锁处理并发</strong><br>因为Actor对象不会共享其可变状态，而且他们在同一时刻仅会接受处理一条消息，所以在对消息做出回应前Actor对象永远都不会尝试锁定他们的状态</li><li><strong>并行性</strong><br>并行性是通过将单个复杂的处理过程拆分成较小的任务以并发处理的方式执行他们实现的</li><li><strong>系统性</strong><br>单个Actor对象是不具备并行性的。Actor对象是非常轻量的，因此在在单个系统中创建多个Actor对象是推荐的处理方式。<em>任何问题都可以通过添加Actor对象来解决</em></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="actor" scheme="https//raylax.github.io/categories/actor/"/>
    
    
      <category term="actor" scheme="https//raylax.github.io/tags/actor/"/>
    
      <category term="scala" scheme="https//raylax.github.io/tags/scala/"/>
    
      <category term="akka" scheme="https//raylax.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>java-String/StringBuilder/StringBuffer区别</title>
    <link href="https//raylax.github.io/post/java/string-stringbuilder-stringbuffer.html"/>
    <id>https//raylax.github.io/post/java/string-stringbuilder-stringbuffer.html</id>
    <published>2019-01-28T14:29:04.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java.lang.String部分代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<em>String</em>是一个<em>final</em>修饰不可继承的类，内部使用<em>final</em>修饰的<em>char[]</em>来保存数据，String是不可变的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line">System.out.println((str + <span class="string">"456"</span>) == str);</span><br><span class="line"><span class="comment">// output : false</span></span><br></pre></td></tr></table></figure><p></p><p>每次对String拼接都会创建一个新String对象</p><h3 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h3><p><em>AbstractStringBuilder</em>是一个抽象类，是<em>StringBuilder</em>和<em>StringBuffer</em>的父类，二者大部分操作都是基于此类实现的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java.lang.AbstractStringBuilder部分代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><em>AbstractStringBuilder</em>是一个可变的字符串类，内部使用<em>char[]</em>来保存数据，<em>count</em>用来记录<em>value</em>已用长度。<br>每次<em>append</em>操作都会向<em>value</em>中添加数据，若数组容量不够则进行扩容，扩容后容量是原容量的2倍<br><em>append</em>操作并不会创建新对象，而是在原有对象上进行修改，所以<em>AbstractStringBuilder</em>是可变的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder bd = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(bd.append(<span class="string">"345"</span>) == bd);</span><br><span class="line"><span class="comment">// output : true</span></span><br><span class="line">StringBuffer bf = <span class="keyword">new</span> StringBuffer(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(bf.append(<span class="string">"345"</span>) == bf);</span><br><span class="line"><span class="comment">// output : true</span></span><br></pre></td></tr></table></figure><p></p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p><em>StringBuilder</em>继承<em>AbstractStringBuilder</em>类所有方法均调用父类实现</p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p><em>StringBuilder</em>继承<em>AbstractStringBuilder</em>类所有方法均调用父类实现<br>所有方法均使用<em>synchronized</em>关键字修饰，所以<em>StringBuffer</em>是线程安全的</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>实际上在编译期优化了的<code>string+</code>操作的运行效率并非低于使用其他两个类<br>因为许多编译器会将此操作优化为<code>builder.append</code>的形式<br>理论上执行效率 StringBuilder &gt; StringBuffer &gt; String</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合-List类</title>
    <link href="https//raylax.github.io/post/java/collection-list.html"/>
    <id>https//raylax.github.io/post/java/collection-list.html</id>
    <published>2019-01-27T14:47:17.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList内部使用数组实现</p><p>内部关键变量<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空列表常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认空列表常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 存放数据数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 列表大小(列表大小并不总是等于elementData.length，因为elementData会有冗余)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p></p><p>构造方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个初始容量为0空列表</span></span><br><span class="line"><span class="comment"> * 使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA填充elementData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 如果initialCapacity大于0，创建一个初始容量为initialCapacity的列表</span></span><br><span class="line"><span class="comment"> * 为elementData创建一个大小为initialCapacity的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果initialCapacity等于0，创建一个初始容量为0的数组</span></span><br><span class="line"><span class="comment"> * 使用EMPTY_ELEMENTDATA填充elementData</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果initialCapacity小于0，抛出IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 传入一个集合如果c长度不为0，将c的数组复制到elementData</span></span><br><span class="line"><span class="comment"> * c的长度赋值到size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br></pre></td></tr></table></figure><p></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>如果使用无参构造创建List，在第一次扩容时如果如果期望容量小于10则会将容量设置为10<br>后续扩容<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>也就是说每次扩容后大小是原数组大小的1.5倍</p><h4 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h4><p>ArrayList实现了<em>RandomAccess</em>接口，实际上<em>RandomAccess</em>内部并无需要实现的方法<br>此接口只是为了标识该列表支持随机访问，也就是支持按下标访问<br>主要用于<code>Collections.binarySearch</code>等方法区分查找方式</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList内部使用双向链表实现</p><p>内部关键变量<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列表大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 第一个节点指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 最后一个节点指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">// 内部Node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 实际对象</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 指向上一个对象</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 指向下一个对象</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>向头部添加对象会创建一个next指向first的新节点，将first指向新节点<br>向指定位置添加对象创建一个prev指向该位置元素的prev，last指向该对象的新节点，原对象prev指向新节点<br>向尾部添加对象会创建一个prev指向last的新节点，将last指向新节点</p><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>LinkedList实现了<em>Deque</em>接口，说明LinkedList实现了可以当做一个双向队列使用，LinkedList使用的数据结构完美的支持双向队列</p><h3 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h3><table><thead><tr><th>操作\类型</th><th style="text-align:center">ArrayList</th><th style="text-align:center">LinkedList</th></tr></thead><tbody><tr><td>获取指定位置对象</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td>向头部添加对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(1)$</td></tr><tr><td>向指定位置添加对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td>向尾部添加对象</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(1)$</td></tr><tr><td>删除头部对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(1)$</td></tr><tr><td>删除指定位置对象</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td>删除尾部对象</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(1)$</td></tr></tbody></table><h3 id="Vector与ArrayList区别"><a href="#Vector与ArrayList区别" class="headerlink" title="Vector与ArrayList区别"></a>Vector与ArrayList区别</h3><p><em>Vector</em>与<em>ArrayList</em>实现原理基本类似<br>主要区别在于，<em>Vector</em>每个方法都是加了<em>synchronized</em>同步的，是线程安全的<br>而<em>ArrayList</em>是非线程安全的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="集合" scheme="https//raylax.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java并发-synchronized关键字&amp;CAS锁</title>
    <link href="https//raylax.github.io/post/java/concurrent-synchronized-cas-lock.html"/>
    <id>https//raylax.github.io/post/java/concurrent-synchronized-cas-lock.html</id>
    <published>2019-01-26T11:08:29.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>java中提供了<em>synchronized</em>关键字和<em>java.util.concurrent.locks</em>包下的相关类来进行线程同步</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>在1.6之前<em>synchronized</em>是一个重量级锁，此同步方式同步成本非常高，因为阻塞线程会引起用户态和内核态之间切换。此后jvm对此同步方式进行了许多优化(偏向锁、轻量级锁)可以放心使用，而且因为是java关键字所以也可以享受以后的优化并且不需要更改代码</p><table><thead><tr><th>修饰</th><th>锁对象</th></tr></thead><tbody><tr><td>静态方法</td><td>当前类对象(class)</td></tr><tr><td>实例方法</td><td>当前实例(this)</td></tr><tr><td>修饰代码块</td><td>指定变量</td></tr></tbody></table><p><em>synchronized</em>锁膨胀过程 [偏向锁] -&gt; [轻量级锁] -&gt; [重量级锁]</p><ul><li><strong>偏向锁</strong><br>偏向锁会在第一次进行同步访问时的将访问线程的线程ID使用<em>CAS</em>记录到互斥变量的<code>Mark word</code>。<br>以后每次访问则检查访问线程的ID是否等于<em>Mark word</em>中记录的线程ID，如果等于则可以无锁同步。如果线程ID不相同则说明有其他线程竞争，此时偏向锁会膨胀成<em>轻量级锁</em><br>适用场景：自始至终仅有同一线程访问<br>优点：可以实现无锁同步<br>缺点：如果很明显有其他线程竞争则很快将膨胀成轻量级锁</li><li><strong>轻量级锁</strong><br>加锁：为访问线程创建<code>Lock record</code>，将锁对象的<code>Mark word</code>复制到<code>Lock record</code>称为<code>Displaced mark word</code>，尝试使用<em>CAS</em>将<code>Mark word</code>指向<code>Displaced mark word</code>，如果成功则获取锁成功，否则循环重试<br>解锁：使用<code>Displaced mark word</code>替换原对象的<code>Mark word</code><br>轻量级锁会在重试次数过多时膨胀成<em>重量级锁</em><br>适用场景：线程竞争少，非耗时操作<br>优点：可以避免线程阻塞造成的造成的用户态和内核态切换成本<br>缺点：如果进行耗时操作则会循环获取锁占用CPU资源</li><li><strong>重量级锁</strong><br>重量级锁会在利用操作系统底层创建互斥量实现，同步时会造成内核态切换<br>适用场景：线程竞争激烈，耗时操作<br>优点：线程直接阻塞无CPU资源占用<br>缺点：线程阻塞，阻塞和唤醒线程耗时可能会超过代码本身执行时间，性能可能低于<em>轻量级锁</em></li></ul><h3 id="ReentrantLock锁"><a href="#ReentrantLock锁" class="headerlink" title="ReentrantLock锁"></a>ReentrantLock锁</h3><p>ReentrantLock分为公平锁和非公平锁，内部使用<em>CAS</em>方式实现具体原理类似于<em>轻量级锁</em></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><strong>synchronized</strong><ol><li>java关键字，易用</li><li>无需改代码享受jdk优化</li></ol></li><li><strong>ReentrantLock</strong><ol><li>java类，加锁解锁都是实例方法，可以更灵活的控制</li><li>提供<em>Condition</em>可以灵活的控制要唤醒的线程</li><li>可以实现公平锁</li><li>可以中断等待</li></ol></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="并发" scheme="https//raylax.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发-volatile关键字</title>
    <link href="https//raylax.github.io/post/java/concurrent-volatile-keyword.html"/>
    <id>https//raylax.github.io/post/java/concurrent-volatile-keyword.html</id>
    <published>2019-01-24T06:16:31.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>前一篇文章讲了java内存模型相关概念，线程在工作的时候会从主内存中复制数据到工作内存中进行操作，这样多线程情况下就会出现数据一致性问题，使用<em>volatile</em>关键字则可以避免此问题。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果使用<em>volatile</em>关键字修饰一个类的(静态)成员变量，则有两种作用</p><ul><li>确保了多线程对此变量的可见性<br>每次获取变量会强制从主内存获取，每次修改变量后会立即刷新到主内存</li><li>禁止进行指令重排(java虚拟为了优化执行效率会进行指令重排，暂不详细说明)</li></ul><h3 id="volatile可以保证原子性么"><a href="#volatile可以保证原子性么" class="headerlink" title="volatile可以保证原子性么"></a>volatile可以保证原子性么</h3><p>volatile仅能确保每次获取的数据都是最新的数据，并不能保证原子性<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个线程增加10000</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    v.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(v.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果应该是100000，实际上这段代码运行结果并不是100000，因为<em>count++</em>操作不是一个原子操作，<em>++</em>操作会先获取<em>count</em>变量然后对其加一刷新到主内存<br>多线程情况下可能多个线程同时获取了该变量对其操作然后刷新到主内存。例如数据是5，2条线程同时获取了该变量对其+1，同时将6刷新到主内存，这时主内存的数据是6但我们期望的是7<br>要解决这个问题可以用<em>synchronized</em>和<em>ReentrantLock</em>对要操作的数据加同步锁解决此问题</p><h4 id="synchronized解决方式"><a href="#synchronized解决方式" class="headerlink" title="synchronized解决方式"></a>synchronized解决方式</h4><p>synchronized方式通过java内置字节码指令<em>monitorenter</em>和<em>monitorexit</em>实现的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object countMutex = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个线程增加10000</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (v.countMutex) &#123;</span><br><span class="line">                        v.count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(v.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><h4 id="ReentrantLock解决方式"><a href="#ReentrantLock解决方式" class="headerlink" title="ReentrantLock解决方式"></a>ReentrantLock解决方式</h4><p>ReentrantLock方式通过<em>CAS</em>方式实现<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest v = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个线程增加10000</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    v.count++;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(v.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="并发" scheme="https//raylax.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java-内存模型</title>
    <link href="https//raylax.github.io/post/java/memory-model.html"/>
    <id>https//raylax.github.io/post/java/memory-model.html</id>
    <published>2019-01-23T02:20:33.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机程序每条指令都由CPU执行，执行过程中会对数据进行操作，程序运行时的临时数据都储存在内存中。<br>但是CPU执行指令的速度远远大于内存读取/写入速度，如果每次操作都需要对内存进行一次操作会大幅度降低CPU运行速度，所以CPU引入高速缓存(L1/L2/L3)来提高读写速度，如果需要对某条数据进行操作，CPU会从内存中复制数据到高速缓存中，然后对其进行一系列操作操作，结束后刷新到内存里。<br>引入高速缓存很好的解决了CPU执行的效率问题，但引发了一致性问题，即在多核心状态下，每个核心都有自己的高速缓存，无法保证同一数据不同核心下的高速缓存是一致的。CPU通过缓存一致性协议来解决了这个问题，例如Intel MESI协议，这里不做过多说明。<br>Java虚拟机中定义了一种类似的Java内存模型，来屏蔽各硬件平台和操作系统之间的差异以及提高程序运行效率。</p><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="/img/post/jmm.jpg" alt=""></div><div class="image-caption"></div></figure><ul><li><strong>堆内存</strong><br>共享区域<br>java虚拟机管理的最大内存区域，几乎所有的对象都会在此区域分配。<br>在需要时自行扩展，可以通过<code>-Xmx|-Xms</code>来控制大小，当此区域内存回收后无法为新对象分配空间且无法扩展，则会抛出<em>OutOfMemoryError</em>异常</li><li><strong>方法区</strong><br>共享区域<br>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li><strong>栈内存</strong><br>线程私有<br>用于存储局部变量表、操作栈、动态链接、方法出口等信息。<br>该区域内存用尽会抛出<em>StackOverFlow</em>异常，常见于递归操作，可以通过<code>-Xss</code>参数来调解栈内存大小</li><li><strong>本地方法区</strong><br>线程私有<br>为Native方法服务，规范中并未明确定义数据结构和使用方式</li><li><strong>程序计数器</strong><br>线程私有<br>用于记录当前执行的字节码的行号，java虚拟机利用计数器来实现循环、跳转以及线程切换恢复执行。</li></ul><blockquote><p>使用nio分配堆外内存暂不说明</p></blockquote><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="/img/post/jmm_1.png" alt=""></div><div class="image-caption"></div></figure><p>所有对象都储存在主内存中，不包括局部变量和方法参数，局部变量与方法参数是线程私有的。<br>每个线程还有自己的工作内存，类似于CPU的高速缓存。当每个线程工作时会从主内存中拷贝一份数据到工作内存，在工作内存进行操作，操作完成后才会刷新到主内存中。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-bean管理</title>
    <link href="https//raylax.github.io/post/java/spring-bean.html"/>
    <id>https//raylax.github.io/post/java/spring-bean.html</id>
    <published>2019-01-22T10:01:56.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Spring中所有的bean都由IoC容器管理，IoC容器负责创建/销毁bean，Spring中的IoC容器即<strong>BeanFactory</strong>，<strong>BeanFactory</strong>为一个接口，Srping中所有的<strong>ApplicationContext</strong>都实现了此接口。</p></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Spring中定义了4种bean的作用域以适应不同业务场景</p><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>单例方式存在，只创建一个实例，每次获取都返回该实例(默认)</td></tr><tr><td>prototype</td><td>每次获取都创建一个新实例</td></tr><tr><td>request</td><td>同一请求下每次获取实例都返回同一个实例(仅限于WebApplicationContext)</td></tr><tr><td>session</td><td>同一会话下每次获取实例都返回同一个实例(仅限于WebApplicationContext)</td></tr></tbody></table><blockquote><p>其中后两者是只有在web环境下才生效的，基于<strong>WebApplicationContext</strong></p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><strong>singleton</strong><br>容器时启动创建，随容器关闭而销毁，可以设置<em>@Lazy</em>注解使其在第一次获取时创建</li><li><strong>prototype</strong><br>该作用域的实例Spring并不负责管理生命周期</li><li><strong>request</strong><br>随每个请求创建/销毁</li><li><strong>session</strong><br>随每个会话创建/销毁</li></ul><h3 id="生命周期监控"><a href="#生命周期监控" class="headerlink" title="生命周期监控"></a>生命周期监控</h3><blockquote><p>Spring管理的bean的生命周期可以使用一系列接口/注解来监控bean的生命周期</p></blockquote><h4 id="实例级监控"><a href="#实例级监控" class="headerlink" title="实例级监控"></a>实例级监控</h4><ul><li><strong>InitializingBean#afterPropertiesSet</strong><br>在bean初始化成功后调用</li><li><strong>DiposableBean#destroy</strong><br>在bean销毁前调用</li><li><strong>@PostConstruct</strong><br>该注解修饰的方法会在bean创建后调用</li><li><strong>@PreDestroy</strong><br>该注解修饰的方法会在bean销毁前调用<blockquote><p><code>@PostConstruct</code>修饰的方法先于<code>InitializingBean#afterPropertiesSet</code>执行<br><code>@PreDestroy</code>修饰的方法先于<code>DiposableBean#destroy</code>执行</p></blockquote></li></ul><h4 id="容器级监控"><a href="#容器级监控" class="headerlink" title="容器级监控"></a>容器级监控</h4><ul><li><strong>BeanPostProcessor#postProcessBeforeInitialization</strong><br>方法会在bean初始化前调用，先于<code>@PostConstruct|InitializingBean#afterPropertiesSet</code>执行</li><li><strong>BeanPostProcessor#postProcessAfterInitialization</strong><br>方法会在bean初始化前调用，后于<code>@PostConstruct|InitializingBean#afterPropertiesSet</code>执行</li></ul><h3 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h3><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="/img/post/spring-bean-lifecycle.jpeg" alt="上面这张图完整描述了bean的生命周期(图片来源于网络)"></div><div class="image-caption">上面这张图完整描述了bean的生命周期(图片来源于网络)</div></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="spring" scheme="https//raylax.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-事务隔离级别</title>
    <link href="https//raylax.github.io/post/mysql-transaction-isolation.html"/>
    <id>https//raylax.github.io/post/mysql-transaction-isolation.html</id>
    <published>2019-01-21T06:18:25.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h3><ul><li><strong>原子性(Atomicity)</strong><br>一个事物内的所有操作视为一个不可分割的操作，事务内所有操要么全执行成功要么全失败<br>例如：一个事务内A给B转账，先从A账户中扣钱，然后向B账户中加对应的钱数，这两次数据库操作要么全成功要么全失败，不能某个操作成功了，其他的失败了</li><li><strong>一致性(Consistency)</strong><br>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少(摘自百度)<br>例如：一共有2个账户，这些账户的总余额为100，无论如何进行并发操作最终这2个账户的余额的和必须为100</li><li><strong>隔离性(Isolation)</strong><br>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作</li><li><strong>持久性(Durability)</strong><br>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><blockquote><p><strong>完全隔离</strong>是不现实的，因为完全隔离会使事务串行化，严重影响并发性能，所以引入隔离级别来控制并发访问</p></blockquote><p>MySQl支持4中隔离级别</p><table><thead><tr><th>隔离级别</th><th>描述</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td>一个事务可以读其他事务未提交的数据</td></tr><tr><td>读已提交(read committed)</td><td>一个事务只能读其他事务已提交的数据</td></tr><tr><td>可重复读(repeatable read)</td><td>一个事务内多次读同一数据必须一致(MySQL默认隔离级别)</td></tr><tr><td>串行化(serializable)</td><td>事务串行化，同一个表同时只能有一个事务进行操作</td></tr></tbody></table><h3 id="并发引发问题"><a href="#并发引发问题" class="headerlink" title="并发引发问题"></a>并发引发问题</h3><ul><li><strong>脏读</strong><br>A事务读取了B事务未提交的数据并在此基础上进行操作，结果B事务回滚了，那么A所进行的操作就是有问题的</li><li><strong>不可重复读</strong><br>不可重复读指同一事务中两次读取的数据不一致，A事务读取了一条数据，B事务修改了数据并且提交了，A事务又读了此条数据结果与上一读取的数据不一致</li><li><strong>幻读</strong><br>事务A统计了数据量，事务B添加了N条记录，事务B又查了一次，结果两次结果数量不一致</li></ul><h3 id="隔离级别对应问题"><a href="#隔离级别对应问题" class="headerlink" title="隔离级别对应问题"></a>隔离级别对应问题</h3><blockquote><p>隔离级别越往下并发效率越低，<strong>可重复读</strong>行级锁，<strong>串行化</strong>表级锁</p></blockquote><table><thead><tr><th>级别\问题</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td></tr><tr><td>读已提交(read committed)</td><td style="text-align:center">√</td><td style="text-align:center">x</td><td style="text-align:center">x</td></tr><tr><td>可重复读(repeatable read)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">x</td></tr><tr><td>串行化(serializable)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>只有<code>InnoDB</code>引擎支持事务并且支持行级锁，<code>MyISAM</code>引擎并不支持事务且仅支持表级锁<br><code>InnoDB</code>适合频繁update业务场景(交易系统)，<code>MyISAM</code>适用于大量select、insert业务场景(日志类系统)<br>处理数据库并发问题并非只能依靠数据来处理，可以结合代码进行合理的加锁，例如依靠外部<code>redis/zookeeper</code>做分布式锁</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;事务ACID特性&quot;&gt;&lt;a href=&quot;#事务ACID特性&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="database" scheme="https//raylax.github.io/categories/database/"/>
    
    
      <category term="mysql" scheme="https//raylax.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Spring-事物传播方式/机制</title>
    <link href="https//raylax.github.io/post/java/spring-transaction.html"/>
    <id>https//raylax.github.io/post/java/spring-transaction.html</id>
    <published>2019-01-20T10:55:03.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Spring在<code>org.springframework.transaction.TransactionDefinition</code>中定义了七中事物传播方式，规定了需要执行事物的方法和事物发生嵌套时如何进行传播</p><table><thead><tr><th>传播方式</th><th>描述</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>支持当前事务，如果没有事务则创建一个事务</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果没有事务则已非事务方式执行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>支持当前事务，如果没有事务则抛异常</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>创建新事务，如果已存在事务则挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>不支持当前事务，如果存在则以非事务方式执行</td></tr><tr><td>PROPAGATION_NEVER</td><td>不支持当前事务，如果存在则抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务则执行嵌套事务，否则以类似PROPAGATION_REQUIRED方式执行</td></tr></tbody></table><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><blockquote><p>除了<code>PROPAGATION_REQUIRES_NEW</code>和<code>PROPAGATION_NESTED</code>其他都很好理解，主要解释下这两者的区别</p></blockquote><h4 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h4><p>创建一个独立的”内部”事务，挂起原有事务，此事务与原事务互不依赖<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserServiceAImpl.java</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(UserEntity user)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"UserServiceAImpl#addUser begin"</span>);</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    userServiceB.updateUser(user);</span><br><span class="line">    logger.info(<span class="string">"UserServiceAImpl#addUser complete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserServiceBImpl.java</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(UserEntity user)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"UserServiceBImpl#updateUser begin"</span>);</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    logger.info(<span class="string">"UserServiceBImpl#updateUser complete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line">UserEntity user = <span class="keyword">new</span> UserEntity(<span class="string">"raylax"</span>);</span><br><span class="line">userServiceA.addUser(user);</span><br></pre></td></tr></table></figure><p></p><p>截取部分运行日志<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 创建事务</span><br><span class="line">Creating new transaction with name [UserServiceAImpl.addUser]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">Opened new EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transaction</span><br><span class="line">Exposing JPA transaction as JDBC [HibernateConnectionHandle@580902cd]</span><br><span class="line"># 进入addUser方法</span><br><span class="line">UserServiceAImpl#addUser begin</span><br><span class="line">Found thread-bound EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transaction</span><br><span class="line">Participating in existing transaction</span><br><span class="line">Found thread-bound EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transaction</span><br><span class="line"># 挂起当前事务</span><br><span class="line">Suspending current transaction, creating new transaction with name [UserServiceBImpl.updateUser]</span><br><span class="line"># 创建新事务</span><br><span class="line">Opened new EntityManager [SessionImpl(40626598&lt;open&gt;)] for JPA transaction</span><br><span class="line">Exposing JPA transaction as JDBC [HibernateConnectionHandle@4d518c66]</span><br><span class="line"># 进入updateUser方法</span><br><span class="line">UserServiceBImpl#updateUser begin</span><br><span class="line">Found thread-bound EntityManager [SessionImpl(40626598&lt;open&gt;)] for JPA transaction</span><br><span class="line">Participating in existing transaction</span><br><span class="line"># 退出updateUser方法</span><br><span class="line">UserServiceBImpl#updateUser complete</span><br><span class="line"># 提交新事务</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JPA transaction on EntityManager [SessionImpl(40626598&lt;open&gt;)]</span><br><span class="line">Closing JPA EntityManager [SessionImpl(40626598&lt;open&gt;)] after transaction</span><br><span class="line"># 恢复被挂起的事务</span><br><span class="line">Resuming suspended transaction after completion of inner transaction</span><br><span class="line"># 退出addUser方法</span><br><span class="line">UserServiceAImpl#addUser complete</span><br><span class="line"># 提交原事务</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JPA transaction on EntityManager [SessionImpl(254041053&lt;open&gt;)]</span><br></pre></td></tr></table></figure><p></p><h4 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h4><p>如果当前存在事务则执行嵌套事务，否则以类似PROPAGATION_REQUIRED方式执行<br>嵌套事务创建同时会创建一个<code>savepoint</code>如果该事务发生异常会回滚到<code>savepoint</code><br>嵌套事务会跟随父事务commit/rollback</p><blockquote><p>NESTED需要基于<code>JDBC3.0</code>并且事务支持<code>savepoint</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserServiceAImpl.java</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(UserEntity user)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"UserServiceAImpl#addUser begin"</span>);</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"insert into t_user values(1, '"</span>  + user.getName() + <span class="string">"')"</span>);</span><br><span class="line">    userServiceB.updateUser(user);</span><br><span class="line">    logger.info(<span class="string">"UserServiceAImpl#addUser complete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserServiceBImpl.java</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(UserEntity user)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"UserServiceBImpl#updateUser begin"</span>);</span><br><span class="line">    jdbcTemplate.update(<span class="string">"update t_user set name = '"</span> + user.getName() + <span class="string">"-updated'"</span>);</span><br><span class="line">    logger.info(<span class="string">"UserServiceBImpl#updateUser complete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line">UserEntity user = <span class="keyword">new</span> UserEntity(<span class="string">"raylax"</span>);</span><br><span class="line">userServiceA.addUser(user);</span><br></pre></td></tr></table></figure><p>截取部分运行日志<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 创建事务</span><br><span class="line">Acquired Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] for JDBC transaction</span><br><span class="line">Switching JDBC Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] to manual commit</span><br><span class="line"># 进入addUser方法</span><br><span class="line">UserServiceAImpl#addUser begin</span><br><span class="line">Executing SQL statement [insert into t_user values(1, &apos;raylax&apos;)]</span><br><span class="line"># 创建嵌套事务，创建保存点</span><br><span class="line">Creating nested transaction with name [UserServiceBImpl.updateUser]</span><br><span class="line"># 进入updateUser方法</span><br><span class="line">UserServiceBImpl#updateUser begin</span><br><span class="line">Executing SQL update [update t_user set name = &apos;raylax-updated&apos; where id = null]</span><br><span class="line"># 退出updateUser方法</span><br><span class="line">UserServiceBImpl#updateUser complete</span><br><span class="line"># 释放保存点</span><br><span class="line">Releasing transaction savepoint</span><br><span class="line"># 退出addUser方法</span><br><span class="line">UserServiceAImpl#addUser complete</span><br><span class="line"># 提交事务，嵌套事务会跟随提交</span><br><span class="line">Initiating transaction commit</span><br><span class="line">Committing JDBC transaction on Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a]</span><br><span class="line">Releasing JDBC Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] after transaction</span><br></pre></td></tr></table></figure><p></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>事务默认以<code>PROPAGATION_REQUIRED</code>方式执行<br>事务传播的控制基于<code>AOP</code>，所以只有调用spring管理的实例方法时生效，调用this指向方法不生效<br>例如ClassA调用methodA，methodA中调用了ClassB的methodB此时传播控制才生效<br>如ClassA调用methodA，methodA中调用调用了内部的methodB则会以<code>PROPAGATION_REQUIRED</code>方式执行，传播控制不生效</p></blockquote><h4 id="生效示例"><a href="#生效示例" class="headerlink" title="生效示例"></a>生效示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassA.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    classB.methodB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClassB.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line">classA.methodA();</span><br></pre></td></tr></table></figure><h4 id="不生效示例"><a href="#不生效示例" class="headerlink" title="不生效示例"></a>不生效示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassA.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line">classA.methodA();</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
      <category term="spring" scheme="https//raylax.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA-JDK和CGLIB动态代理使用</title>
    <link href="https//raylax.github.io/post/java/jdk-proxy-cglib-proxy-use.html"/>
    <id>https//raylax.github.io/post/java/jdk-proxy-cglib-proxy-use.html</id>
    <published>2019-01-20T10:50:33.000Z</published>
    <updated>2021-01-22T09:55:41.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式即给某一对象生成一个代理对象，来对原对象进行一些访问控制<br>通过代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>鉴权、事物、日志、异常处理…</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>优点：面向接口编程屏蔽内部实现，如需修改实现类直接修改代理类即可<br>缺点：每个代理类只能为一个接口服务，需要为每个接口创建代理。实现类与代理类都实现了相同的接口，如增加一个方法所有代理类都需要进行修改，增加了维护的复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do action !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyPerson</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person = <span class="keyword">new</span> RealPerson();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            person.doAction();</span><br><span class="line">            System.out.println(<span class="string">"method complete"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> ProxyPerson();</span><br><span class="line">    person.doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>需要用到的类<code>java.lang.reflect.InvocationHandler</code>和<code>java.lang.reflect.Proxy</code><br><code>Proxy</code>为原对象的代理对象<br><code>InvocationHandler#invoke</code>方法会在代理对象被调用时调用，可以在此处做处理<br><code>Proxy#newProxyInstance</code>方法的第二个参数必须为接口，所以JDK动态代理只能为实现了接口的类生成代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do action !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClass</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object realObject;</span><br><span class="line">    ProxyClass(Object realObject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.realObject = realObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                realObject.getClass().getClassLoader(),</span><br><span class="line">                realObject.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用反射调用原对象方法</span></span><br><span class="line">            Object result = method.invoke(realObject, args);</span><br><span class="line">            System.out.println(<span class="string">"method complete"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method error"</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = (Person) <span class="keyword">new</span> ProxyClass(<span class="keyword">new</span> RealPerson()).newProxy();</span><br><span class="line">    person.doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><p>CGLib动态代理底层采用ASM字节码生成框架，使用字节码技术生成代理类，原理是生成目标类的子类。CGLib可以为未实现接口的类生成代理，但无法为<code>final</code>类生成代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do action !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClass</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用父类方法</span></span><br><span class="line">            Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">            System.out.println(<span class="string">"method complete"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method error"</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RealPerson person = (RealPerson) <span class="keyword">new</span> ProxyClass().newProxy(RealPerson.class);</span><br><span class="line">    person.doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 22 2021 09:56:24 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理
      
    
    </summary>
    
      <category term="java" scheme="https//raylax.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https//raylax.github.io/tags/java/"/>
    
  </entry>
  
</feed>
