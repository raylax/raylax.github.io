{"meta":{"title":"raylax'Blog","subtitle":null,"description":null,"author":"raylax","url":"https//raylax.github.io"},"pages":[{"title":"","date":"2021-01-20T10:23:11.096Z","updated":"2021-01-20T10:23:11.096Z","comments":false,"path":"categories/index.html","permalink":"https//raylax.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-01-20T10:23:11.096Z","updated":"2021-01-20T10:23:11.096Z","comments":false,"path":"tags/index.html","permalink":"https//raylax.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发之AQS相关代码分析-CountDownLatch","slug":"java/aqs-count-down-latch","date":"2021-01-17T15:06:01.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/aqs-count-down-latch.html","link":"","permalink":"https//raylax.github.io/post/java/aqs-count-down-latch.html","excerpt":"","text":"方法12345678// 构造方法public CountDownLatch(int count);// 释放public void countDown();// 等待public void await() throws InterruptedException;// 等待（带超时时间）public boolean await(long timeout, TimeUnit unit) throws InterruptedException源码分析构造方法123456789101112// CountDownLatchpublic CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count);&#125;// CountDownLatch.Syncprivate static final class Sync extends AbstractQueuedSynchronizer &#123; Sync(int count) &#123; // 设置state setState(count); &#125;&#125;countDown调用AQS#releaseShared(int arg)方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// AbstractQueuedSynchronizerpublic final boolean releaseShared(int arg) &#123; // 尝试释放共享资源 if (tryReleaseShared(arg)) &#123; // 如果全部释放完成唤醒等待队列 doReleaseShared(); return true; &#125; return false;&#125;// CountDownLatch.Syncprotected boolean tryReleaseShared(int releases) &#123; // 自旋 for (;;) &#123; // 获取当前状态 int c = getState(); // 如果释放完了直接返回 if (c == 0) return false; // 减一 int nextc = c-1; // 如果CAS设置不成功自旋 if (compareAndSetState(c, nextc)) return nextc == 0; // 如果等于0说明全部释放完成 &#125;&#125;// AbstractQueuedSynchronizerprivate void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // unparkSuccessor相关源码在ReentrantLock已经讲过 unparkSuccessor(h); // 如果是SIGNAL并且CAS设置初始状态成功则唤醒线程 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 如果是初始状态则设置状态为PROPAGATE continue; &#125; if (h == head) // 正常调用过unparkSuccessor后其他线程会竞争改变head，如果head没变跳出循环 break; &#125;&#125;await调用AQS#acquireSharedInterruptibly(int arg)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// AbstractQueuedSynchronizerpublic final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 如果线程被中断，抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); // 如果还有待释放的state值&#125;// CountDownLatch.Syncprotected int tryAcquireShared(int acquires) &#123; // 如果全部释放返回1否则返回-1 return (getState() == 0) ? 1 : -1;&#125;// AbstractQueuedSynchronizerprivate void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 添加到共享等待队列，相关源码在ReentrantLock已经讲过 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取当前节点的前驱节点 final Node p = node.predecessor(); // 如果前驱节点是头节点，再次尝试获取 if (p == head) &#123; int r = tryAcquireShared(arg); // &gt;=0 说明state==0 countdown结束 if (r &gt;= 0) &#123; // 设置当前节点为head并向后传播 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // 如果获取失败 if (shouldParkAfterFailedAcquire(p, node) // 判断是否可以挂起线程 &amp;&amp; parkAndCheckInterrupt()) // 挂起线程等待唤醒 throw new InterruptedException(); &#125; &#125; finally &#123; // 如果失败了则取消获取 if (failed) cancelAcquire(node); &#125;&#125;// AbstractQueuedSynchronizerprivate void setHeadAndPropagate(Node node, int propagate) &#123; // 保存原始head Node h = head; // 把当前节点设置为head setHead(node); // propagate &gt; 0 永远是true // 如果头节点是null或者waitStatus是有效地 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 如果后继节点是共享的释放共享锁 if (s == null || s.isShared()) doReleaseShared(); &#125;&#125;await(long timeout, TimeUnit unit)调用AQS#tryAcquireSharedNanos(int arg, long nanosTimeout)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// AbstractQueuedSynchronizerpublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 如果获取成功直接返回 return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout); // 超时等待&#125;// AbstractQueuedSynchronizerstatic final long spinForTimeoutThreshold = 1000L;private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; // 计算deadline final long deadline = System.nanoTime() + nanosTimeout; // 添加到等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // 尝试获取 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return true; &#125; &#125; // 重新计算超时时间 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) // 如果超过1000才会挂起线程，否则直接自旋 LockSupport.parkNanos(this, nanosTimeout); // 带超时挂起线程 // 如果中断抛出异常 if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; // 如果失败了则取消获取 if (failed) cancelAcquire(node); &#125;&#125;以上所有未详细解释方法在ReentrantLock已经讲过","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"AQS","slug":"AQS","permalink":"https//raylax.github.io/tags/AQS/"}]},{"title":"Java并发之AQS相关代码分析-CountDownLatch","slug":"java-aqs-count-down-latch","date":"2021-01-17T15:06:01.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java-aqs-count-down-latch.html","link":"","permalink":"https//raylax.github.io/post/java-aqs-count-down-latch.html","excerpt":"","text":"概述","categories":[],"tags":[]},{"title":"Java并发之AQS相关代码分析-ReentrantLock","slug":"java/aqs-reentrant-lock","date":"2021-01-12T06:17:28.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/aqs-reentrant-lock.html","link":"","permalink":"https//raylax.github.io/post/java/aqs-reentrant-lock.html","excerpt":"","text":"概述Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization.AQS类是了一个实现了阻塞锁的抽象队列同步器，是ReentrantLock、Semaphore、CountDownLatch的基础内部维护一个state状态值和一个FIFO队列内部变量123456789101112// 共享资源private volatile int state;// 获取状态protected final int getState();// 设置状态protected final void setState(int newState);// CAS设置状态protected final boolean compareAndSetState(int expect, int update);// FIFO对列头private transient volatile Node head;// FIFO对列尾private transient volatile Node tail;详解ReentrantLock是依赖AQS实现的一个可重入锁，我们通过分析ReentrantLock工作流程来分析AQS实现ReentrantLock中实现了公平和非公平两种形似，暂且只分析公平锁locklock方法直接调用AQS#acquire(int arg)方法1234567public final void acquire(int arg) &#123; // 如果获取到资源直接返回 if (!tryAcquire(arg) &amp;&amp; // 如果获取资源失败进入等待对列 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;tryAcquiretryAcquire方法由子类ReentrantLock.FairSync类实现123456789101112131415161718192021222324252627282930protected final boolean tryAcquire(int acquires) &#123; // 获取当前线程 final Thread current = Thread.currentThread(); // 获取资源 int c = getState(); // 如果状态是未锁定 if (c == 0) &#123; // 如果不需要排队等待则CAS设置state值 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; // 设置独占线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果资源已经锁定并且独占线程是当前线程 else if (current == getExclusiveOwnerThread()) &#123; // 增加state值 int nextc = c + acquires; // 判断是否溢出 if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); // 设置状态值 // 只有独占的同一个线程才能进入这个分支，所以这里无需使用CAS setState(nextc); return true; &#125; // 如果上述条件都不符合说明获取失败 return false;&#125;hasQueuedPredecessors123456789101112// 判断队列中是否有正在等待的public final boolean hasQueuedPredecessors() &#123; // 根据enq方法可知，如果head和tail二者只有一个为null只有可能是head不为null，tail为null Node t = tail; Node h = head; Node s; // h == t // h == t == null 未初始化过 // h == t != null 对列中只有一个等待者 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125;addWaiter123456789101112131415161718// 加入等待对列private Node addWaiter(Node mode) &#123; // 创建节点 Node node = new Node(Thread.currentThread(), mode); // 如果对列尾不为null，说明已经初始化过 Node pred = tail; if (pred != null) &#123; node.prev = pred; // 设置新节点为尾节点 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 如果没有初始化或者设置失败则进入自旋 enq(node); return node;&#125;enq1234567891011121314151617private Node enq(final Node node) &#123; // 自旋 for (;;) &#123; Node t = tail; if (t == null) &#123; // 初始化 if (compareAndSetHead(new Node())) // 如果此时发生并发则head不为null，tail为null tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125;acquireQueued123456789101112131415161718192021222324252627282930// 等待获取final boolean acquireQueued(final Node node, int arg) &#123; // 是否失败 boolean failed = true; try &#123; // 是否中断 boolean interrupted = false; for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); // 如果前驱节点是头节点则尝试获取 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 如果获取成功则将当前节点设置成头节点 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 判断是否需要挂起 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // 挂起当前线程 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; // 如果失败取消获取 if (failed) cancelAcquire(node); &#125;&#125;shouldParkAfterFailedAcquire1234567891011121314151617181920private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 前驱节点状态 0初始状态 小于0表示节点有效 大于0表示已取消 int ws = pred.waitStatus; // 如果waitStatus已经设置好了直接返回 if (ws == Node.SIGNAL) return true; // 如果前驱节状态无效 if (ws &gt; 0) &#123; // 依次向前查找有效节点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); // 设置前驱节点 pred.next = node; &#125; else &#123; // 设置waitStatus信号量 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;cancelAcquire123456789101112131415161718192021222324252627282930313233343536373839private void cancelAcquire(Node node) &#123; // 如果节点已经不存在，直接忽略 if (node == null) return; // 清除线程 node.thread = null; // 前驱节点 Node pred = node.prev; // 循环向前寻找有效节点 while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // 前驱节点的下一个节点 Node predNext = pred.next; // 设置节点为无效状态 node.waitStatus = Node.CANCELLED; // 如果当前节点是尾节点，则直接设置尾节点为当前节点前第一个有效节点 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; // 设置前驱节点的next为null compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; // 前驱节点不是头节点 if (pred != head &amp;&amp; // 如果前驱节点等于SIGNAL或者可以设置为SIGNAL，并且前驱节点的线程不是null ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; // 将当前节点的后驱节点设置为前驱节点的后驱节点 Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; // 如果前驱节点是头节点则唤醒后驱节点 unparkSuccessor(node); &#125; node.next = node; &#125;&#125;unparkSuccessor123456789101112131415161718192021// 唤醒节点的后驱节点private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 如果是正常状态则设置为初始状态 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 取后驱节点 Node s = node.next; // 如果后驱节点不是null并且后驱节点状态无效 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从尾部向前遍历有效节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 如果节点存在，唤醒节点 if (s != null) LockSupport.unpark(s.thread);&#125;unlocklock方法直接调用AQS#release(int arg)方法123456789101112public final boolean release(int arg) &#123; // 尝试释放 if (tryRelease(arg)) &#123; Node h = head; // 如果释放成功并且waitStatus不是初始状态 if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒后驱及节点 unparkSuccessor(h); return true; &#125; return false;&#125;tryRelease12345678910111213141516protected final boolean tryRelease(int releases) &#123; // 更后的state int c = getState() - releases; // 如果当前线程不是锁的拥有者，直接抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; // 清除独占 setExclusiveOwnerThread(null); &#125; // 设置新的state setState(c); return free;&#125;非公平模式上面讲了公平模式ReentrantLock也可以设置为非公平模式，主要区别在获取时并不判断当前线程是否是等待队列头1234567891011121314151617181920212223242526final boolean nonfairTryAcquire(int acquires) &#123; // 当前线程 final Thread current = Thread.currentThread(); // 当前状态 int c = getState(); // 如果未锁定状态 if (c == 0) &#123; // CAS设置状态 if (compareAndSetState(0, acquires)) &#123; // 设置独占线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果独占线程是当前线程，增加状态 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; // 判断溢出 if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); // 设置状态 setState(nextc); return true; &#125; return false;&#125;","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"AQS","slug":"AQS","permalink":"https//raylax.github.io/tags/AQS/"}]},{"title":"jvm命令行参数","slug":"jvm-command-argments","date":"2019-06-05T01:49:03.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/jvm-command-argments.html","link":"","permalink":"https//raylax.github.io/post/jvm-command-argments.html","excerpt":"","text":"jvm命令行参数标准参数标准参数以-开头，所有jvm都实现了该参数的功能-jar指定运行一个jar包，jar包中manifest文件中必须指定Main-class-cp指定classpath路径-Dproperty=value设置系统属性键值对，使用System.getProperty(&quot;property&quot;)可以获得value-verbose打印jvm载入类的相关信息-verbose:gc打印gc信息-verbose:jni打印native方法调用信息非标准参数非标准参数以-X开头，默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足-Xms-Xms1g 指定jvm初始内存为1g，避免频繁扩容-Xmx-Xmx1g 指定jvm最大可用内存为1g-Xmn-Xmn1g 指定年轻代大小为1g，整个堆 = 年轻代 + 年老代 + 持久代，增加年轻代容量会缩小年老代容量-Xss-Xss1m 设置线程堆栈大小，默认1m。增加此值会减少可创建的线程数量，反而能增加可创建线程数量。可创建线程数量也受操作系统限制-Xloggc-Xloggc:gc.log 将gc日志记录到gc.log中-Xprof跟踪正运行的程序，并将跟踪数据在标准输出输出非Stable参数非Stable参数以-XX开头-XX:PermSize指非堆内存初始大小-XX:MaxPermSize指对非堆内存上限-XX:-UseSerialGC使用串行GC-XX:-UseParallelGC使用并行GC-XX:-UseConcMarkSweepGC对老年代使用CMSConcurrent Mark And Sweep GC参数描述-XX:LargePageSizeInBytes=4m设置用于Java堆的大页面尺寸-XX:MaxHeapFreeRatio=70GC后java堆中空闲量占的最大比例-XX:MaxNewSize=size新生成对象能占用内存的最大值-XX:MaxPermSize=64m老生代对象能占用内存的最大值-XX:MinHeapFreeRatio=40GC后java堆中空闲量占的最小比例-XX:NewRatio=2新生代内存容量与老生代内存容量的比例-XX:NewSize=2.125m新生代对象生成时占用内存的默认值-XX:ReservedCodeCacheSize=32m保留代码占用的内存容量-XX:ThreadStackSize=512设置线程栈大小，若为0则使用系统默认值-XX:+UseLargePages使用大页面内存-XX:-CITime打印消耗在JIT编译的时间-XX:ErrorFile=./hs_err_pid.log保存错误日志或者数据到文件中-XX:-ExtendedDTraceProbes开启solaris特有的dtrace探针-XX:HeapDumpPath=./java_pid.hprof指定导出堆信息时的路径或文件名-XX:-HeapDumpOnOutOfMemoryError当首次遭遇OOM时导出此时堆中相关信息-XX:OnError=”;“出现致命ERROR之后运行自定义命令-XX:OnOutOfMemoryError=”;“当首次遭遇OOM时执行自定义命令-XX:-PrintClassHistogram遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同-XX:-PrintConcurrentLocks遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同-XX:-PrintCommandLineFlags打印在命令行中出现过的标记-XX:-PrintCompilation当一个方法被编译时打印相关信息-XX:-PrintGC每次GC时打印相关信息-XX:-PrintGC Details每次GC时打印详细信息-XX:-PrintGCTimeStamps打印每次GC的时间戳-XX:-TraceClassLoading跟踪类的加载信息-XX:-TraceClassLoadingPreorder跟踪被引用到的所有类的加载信息-XX:-TraceClassResolution跟踪常量池-XX:-TraceClassUnloading跟踪类的卸载信息-XX:-TraceLoaderConstraints跟踪类加载器约束的相关信息","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https//raylax.github.io/tags/jvm/"}]},{"title":"linux快捷键","slug":"linux-shortcut-keys","date":"2019-05-15T13:33:43.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/linux-shortcut-keys.html","link":"","permalink":"https//raylax.github.io/post/linux-shortcut-keys.html","excerpt":"","text":"1ctrl + u删除从开头到光标处的文本1ctrl + k删除光标到结尾处的文本1ctrl + a光标移动到命令行头1ctrl + e光标移动到命令行尾1alt + f向前移动一个单词1ctrl + w删除一个单词","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https//raylax.github.io/tags/linux/"},{"name":"技巧","slug":"技巧","permalink":"https//raylax.github.io/tags/技巧/"}]},{"title":"MySQL-schema与数据类型优化","slug":"mysql-schema-data-type","date":"2019-03-16T13:01:30.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/mysql-schema-data-type.html","link":"","permalink":"https//raylax.github.io/post/mysql-schema-data-type.html","excerpt":"","text":"数据类型整数名称占用空间(bit)范围（有符号）范围（无符号）tinyint8-128 - 1270 - 255smallint16-32,768 - 32,7670 - 65,535mediumint24-8,388,608 - 8,388,6070 - 16,777,215int32-2,147,483,648 - 2,147,483,6470 - 4,294,967,295bigint64-9,233,372,036,854,775,808 - 9,223,372,036,854,775,8070 - 18,446,744,073,709,551,615有符号范围为$(-2^{n-1}\\sim2^{n-1}-1)$，无符号范围为$(0\\sim2^{n}-1)$整数类型可选unsinged属性，表示不能为负，该属性可以使正数范围提高一倍有符号和无符号使用同样的存储空间，并且具有相同的性能MySQL可以为整数类型指定宽度，例如int(8)。实际上对大多数应用并没有意义，它并不会限制类型的范围，只是规定了一些交互工具（MySQL命令行客户端）来显示字符个数的。对于存储计算来说int(1)和int(10)是一样的实数MySQL支持实数类型为float、double、decimalfloat为单精度浮点类型，使用32字节来储存，double为双精度浮点型，使用64字节来储存上述两种类型为非精确类型MySQL提供精确类型decimal，decimal类型再可以指定decimal(m,n)其中m为总长度n为小数长度，其占用空间为m+1因为decimal计算需要额外的开销，所以非精确小数计算使用float、double。精确计算则使用int类型乘小数点后$10^n$来使用例如123.456需要精确3位，则使用int类型123456来储存，使用时直接除1000即可字符串字符串分定长字符串char和非定长字符串varcharvarchar为可变长度字符串它的优势在于仅适用必要的空间来存储数据，但是由于可变长度更新时会比原来长，则需要额外的扩容或更换存储位置。它适合用于平均长度与最大长度差距很大的场景char为定长字符串，char以给定长度分配足够空间，如果需要保存的数据远远小于定义的长度则会造成空间浪费。他适合储存较短的字符串，因为定长所以不会产生内存碎片，性能高于varchar如何储存取决于存储引擎的实现，并非所有的引擎都会按照此方式处理，以上为通常处理方式数据类型的选择更小更好尽量选择适合业务范围的数据类型。更小的数据类型通常意味着占用更少的磁盘、内存和CPU缓存，处理时需要的占用的CPU周期更短。字段扩容对数据库来说是一个繁重的操作，尽量避免线上对字段进行扩容简单就好复杂的数据类势必会占用更长的CPU周期，所以根据业务需求来选择一个相对简单的数据结构是必要的。对于时间等复杂类型应选用内建数据结构来存储，而非使用字符串来存储避免NULL值如果查询中包含了可为NULL的列会使得索引、索引统计和值得比较变得更加复杂。当可为NULL的列被索引肯能需要更多的空间来索引，所以索引列尽量为非NULL列直接将可为NULL的列改为NOT NULL可能并不能对性能带来大的提升","categories":[{"name":"database","slug":"database","permalink":"https//raylax.github.io/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https//raylax.github.io/tags/mysql/"}]},{"title":"actor-learning-notes-day4","slug":"actor-learning-notes-day4","date":"2019-02-15T11:45:12.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/actor-learning-notes-day4.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day4.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Actor学习笔记day3-作用及消息传递","slug":"actor-learning-notes-day3","date":"2019-02-13T10:36:49.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/actor-learning-notes-day3.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day3.html","excerpt":"","text":"Actor模型的作用Actor系统可以帮助你同时利用多个处理器的核心。为了使指定的Actor对象能够对他通过并发方式收到的消息做出回应，每个核心都会被充分利用。调度器通常被用于将线程池中的线程分配给缓存了消息的Actor对象。在繁忙的系统中消息会不断地进入Actor对象的消息缓存中，调度器会不停的为线程分配工作。一直以无阻塞的方式使用线程，可以获得理想的、高效的并发处理系统。Actor对象的消息传递消息通道消息通道指消息生产者和消息消费者的通信方式，但这种通信方式不会使消息生产者和消息消费者之间有任何联系。在使用Actor模型中，从逻辑上将消息通道就是Actor对象的消息缓存，是一种先入先出的队列。消息消息是构成基于消息系统的基本单位管道和过滤器在使用Actor模型时，使用管道和过滤器能够更从容、更轻松的解决问题消息路由器Actor系统中会使用各种消息路由，其中包括有状态和无状态路由、基于环境和基于上下文的路由、回环路由和基于内容路由消息译码器当消息进入和被送出系统时会进行各种转换，当与其他系统进行整合时很可能需要消息译码器消息端点端点并不是什么特殊的事物，他们仅仅是单个Actor对象","categories":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/categories/actor/"}],"tags":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/tags/actor/"},{"name":"scala","slug":"scala","permalink":"https//raylax.github.io/tags/scala/"},{"name":"akka","slug":"akka","permalink":"https//raylax.github.io/tags/akka/"}]},{"title":"Actor学习笔记day2-akka框架","slug":"actor-learning-notes-day2","date":"2019-02-12T08:49:12.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/actor-learning-notes-day2.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day2.html","excerpt":"","text":"使用akka框架环境 scala sbtscala是一种运行在jvm平台的一门多范式的编程语言sbt是简单构建工具(Simple build tool)的缩写，可以从官网获取akka actor是typesafe(lightbend前身)公司出品的一个Actor框架创建akka-demo文件夹，创建build.sbt并添加以下代码12345678name := \"akka-demo\"version := \"0.1\"scalaVersion := \"2.12.8\"lazy val akkaVersion = \"2.5.20\"libraryDependencies ++= Seq( \"com.typesafe.akka\" %% \"akka-actor\" % akkaVersion, \"com.typesafe.akka\" %% \"akka-testkit\" % akkaVersion,)执行sbt命令等待完成编写程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.inurl.akkaimport akka.actor.&#123;Actor, ActorLogging, ActorRef, ActorSystem, Props&#125;/** * @author raylax */class Greeter(message: String, printerActor: ActorRef) extends Actor &#123; import Greeter._ import Printer._ var greeting = \"\" def receive = &#123; // 保存greeting case WhoToGreet(who) =&gt; greeting = message + \", \" + who // 向printerActor发送Greeting消息 case Greet =&gt; printerActor ! Greeting(greeting) &#125;&#125;object Greeter &#123; def props(message: String, printerActor: ActorRef): Props = Props(new Greeter(message, printerActor)) final case class WhoToGreet(who: String) case object Greet&#125;class Printer extends Actor with ActorLogging &#123; import Printer._ def receive = &#123; // 打印greeting case Greeting(greeting) =&gt; log.info(\"Greeting received (from \" + sender() + \"): \" + greeting) &#125;&#125;object Printer &#123; def props: Props = Props[Printer] final case class Greeting(greeting: String)&#125;object ActorDemo extends App &#123; import Greeter._ // 创建Actor系统 val system: ActorSystem = ActorSystem(\"helloAkka\") // 创建子Actor对象 val printer: ActorRef = system.actorOf(Printer.props, \"printerActor\") val howdyGreeter: ActorRef = system.actorOf(Greeter.props(\"Howdy\", printer), \"howdyGreeter\") val helloGreeter: ActorRef = system.actorOf(Greeter.props(\"Hello\", printer), \"helloGreeter\") val goodDayGreeter: ActorRef = system.actorOf(Greeter.props(\"Good day\", printer), \"goodDayGreeter\") // 发送消息 howdyGreeter ! WhoToGreet(\"Akka\") howdyGreeter ! Greet howdyGreeter ! WhoToGreet(\"Lightbend\") howdyGreeter ! Greet helloGreeter ! WhoToGreet(\"Scala\") helloGreeter ! Greet goodDayGreeter ! WhoToGreet(\"Play\") goodDayGreeter ! Greet&#125;执行程序输出内容1234[INFO] [02/12/2019 17:03:28.281] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Akka[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/helloGreeter#-140442030]): Hello, Scala[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Lightbend[INFO] [02/12/2019 17:03:28.297] [helloAkka-akka.actor.default-dispatcher-7] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/goodDayGreeter#1061792007]): Good day, Play","categories":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/categories/actor/"}],"tags":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/tags/actor/"},{"name":"scala","slug":"scala","permalink":"https//raylax.github.io/tags/scala/"},{"name":"akka","slug":"akka","permalink":"https//raylax.github.io/tags/akka/"}]},{"title":"Actor学习笔记day1-概述","slug":"actor-learning-notes-day1","date":"2019-01-31T13:10:34.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/actor-learning-notes-day1.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day1.html","excerpt":"","text":"概述Actor模型是一种用于处理并发计算的数学模型，他对Actor对象用作并发计算的通用基元。他会对收到的消息做出处理，并且可以做以下事情：向其他Actor对象发送一定数量的消息创建一定数量的新Actor对象设定对下一跳消息的处理方式这些操作并没有先后顺序，并且可以通过并行的方式执行他们在一个Actor系统中，所有的事物都是Actor对象，只有多个Actor对象组成的系统叫做Actor系统，单个Actor对象并不能称为Actor系统。特点通过异步的方式传递消息如果Actor对象A1要给Actor对象A2发送消息M1，就必须知道A2的地址，那么A1就直接可以向A2发送消息。实际上A2会使用独立于A1的线程接受处理消息，A1就要以异步的方式发送消息给A2，实际上消息传输中间有一个中间对象(消息缓存单元)负责消息分发，即便如此我们还是称之为异步直接传输状态机Actor支持有限状态机。当Actor对象转换为某个预设状态时，他就能改变对未来接收到的消息的处理模式。通过改变成为另一种消息处理器Actor对象就成了一种有限状态机*无共享**一个Actor对象不会与其他Actor对象共享组件可变状态无锁处理并发因为Actor对象不会共享其可变状态，而且他们在同一时刻仅会接受处理一条消息，所以在对消息做出回应前Actor对象永远都不会尝试锁定他们的状态并行性并行性是通过将单个复杂的处理过程拆分成较小的任务以并发处理的方式执行他们实现的系统性单个Actor对象是不具备并行性的。Actor对象是非常轻量的，因此在在单个系统中创建多个Actor对象是推荐的处理方式。任何问题都可以通过添加Actor对象来解决","categories":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/categories/actor/"}],"tags":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/tags/actor/"},{"name":"scala","slug":"scala","permalink":"https//raylax.github.io/tags/scala/"},{"name":"akka","slug":"akka","permalink":"https//raylax.github.io/tags/akka/"}]},{"title":"java-String/StringBuilder/StringBuffer区别","slug":"java/string-stringbuilder-stringbuffer","date":"2019-01-28T14:29:04.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/string-stringbuilder-stringbuffer.html","link":"","permalink":"https//raylax.github.io/post/java/string-stringbuilder-stringbuffer.html","excerpt":"","text":"String12345678/* * java.lang.String部分代码 */public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125;首先String是一个final修饰不可继承的类，内部使用final修饰的char[]来保存数据，String是不可变的123String str = \"123\";System.out.println((str + \"456\") == str);// output : false每次对String拼接都会创建一个新String对象AbstractStringBuilderAbstractStringBuilder是一个抽象类，是StringBuilder和StringBuffer的父类，二者大部分操作都是基于此类实现的123456789101112131415/* * java.lang.AbstractStringBuilder部分代码 */abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count;&#125;AbstractStringBuilder是一个可变的字符串类，内部使用char[]来保存数据，count用来记录value已用长度。每次append操作都会向value中添加数据，若数组容量不够则进行扩容，扩容后容量是原容量的2倍append操作并不会创建新对象，而是在原有对象上进行修改，所以AbstractStringBuilder是可变的123456StringBuilder bd = new StringBuilder(\"123\");System.out.println(bd.append(\"345\") == bd);// output : trueStringBuffer bf = new StringBuffer(\"123\");System.out.println(bf.append(\"345\") == bf);// output : trueStringBuilderStringBuilder继承AbstractStringBuilder类所有方法均调用父类实现StringBufferStringBuilder继承AbstractStringBuilder类所有方法均调用父类实现所有方法均使用synchronized关键字修饰，所以StringBuffer是线程安全的结语实际上在编译期优化了的string+操作的运行效率并非低于使用其他两个类因为许多编译器会将此操作优化为builder.append的形式理论上执行效率 StringBuilder &gt; StringBuffer &gt; String","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]},{"title":"java集合-List类","slug":"java/collection-list","date":"2019-01-27T14:47:17.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/collection-list.html","link":"","permalink":"https//raylax.github.io/post/java/collection-list.html","excerpt":"","text":"ArrayListArrayList内部使用数组实现内部关键变量12345678910// 默认初始容量private static final int DEFAULT_CAPACITY = 10;// 空列表常量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 默认空列表常量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 存放数据数组transient Object[] elementData;// 列表大小(列表大小并不总是等于elementData.length，因为elementData会有冗余)private int size;构造方法1234567891011121314151617181920/* * 创建一个初始容量为0空列表 * 使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA填充elementData */public ArrayList();/* * 如果initialCapacity大于0，创建一个初始容量为initialCapacity的列表 * 为elementData创建一个大小为initialCapacity的数组 * * 如果initialCapacity等于0，创建一个初始容量为0的数组 * 使用EMPTY_ELEMENTDATA填充elementData * * 如果initialCapacity小于0，抛出IllegalArgumentException */public ArrayList(int initialCapacity);/* * 传入一个集合如果c长度不为0，将c的数组复制到elementData * c的长度赋值到size */public ArrayList(Collection&lt;? extends E&gt; c);扩容机制如果使用无参构造创建List，在第一次扩容时如果如果期望容量小于10则会将容量设置为10后续扩容newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)也就是说每次扩容后大小是原数组大小的1.5倍RandomAccessArrayList实现了RandomAccess接口，实际上RandomAccess内部并无需要实现的方法此接口只是为了标识该列表支持随机访问，也就是支持按下标访问主要用于Collections.binarySearch等方法区分查找方式LinkedListLinkedList内部使用双向链表实现内部关键变量123456789101112131415// 列表大小transient int size = 0;// 第一个节点指针transient Node&lt;E&gt; first;// 最后一个节点指针transient Node&lt;E&gt; last;// 内部Nodeclass Node&lt;E&gt; &#123; // 实际对象 E item; // 指向上一个对象 Node&lt;E&gt; next; // 指向下一个对象 Node&lt;E&gt; prev;&#125;运行原理向头部添加对象会创建一个next指向first的新节点，将first指向新节点向指定位置添加对象创建一个prev指向该位置元素的prev，last指向该对象的新节点，原对象prev指向新节点向尾部添加对象会创建一个prev指向last的新节点，将last指向新节点DequeLinkedList实现了Deque接口，说明LinkedList实现了可以当做一个双向队列使用，LinkedList使用的数据结构完美的支持双向队列时间复杂度对比操作\\类型ArrayListLinkedList获取指定位置对象$O(1)$$O(n)$向头部添加对象$O(n)$$O(1)$向指定位置添加对象$O(n)$$O(n)$向尾部添加对象$O(1)$$O(1)$删除头部对象$O(n)$$O(1)$删除指定位置对象$O(n)$$O(n)$删除尾部对象$O(1)$$O(1)$Vector与ArrayList区别Vector与ArrayList实现原理基本类似主要区别在于，Vector每个方法都是加了synchronized同步的，是线程安全的而ArrayList是非线程安全的","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"集合","slug":"集合","permalink":"https//raylax.github.io/tags/集合/"}]},{"title":"java并发-synchronized关键字&CAS锁","slug":"java/concurrent-synchronized-cas-lock","date":"2019-01-26T11:08:29.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/concurrent-synchronized-cas-lock.html","link":"","permalink":"https//raylax.github.io/post/java/concurrent-synchronized-cas-lock.html","excerpt":"","text":"引言java中提供了synchronized关键字和java.util.concurrent.locks包下的相关类来进行线程同步synchronized关键字在1.6之前synchronized是一个重量级锁，此同步方式同步成本非常高，因为阻塞线程会引起用户态和内核态之间切换。此后jvm对此同步方式进行了许多优化(偏向锁、轻量级锁)可以放心使用，而且因为是java关键字所以也可以享受以后的优化并且不需要更改代码修饰锁对象静态方法当前类对象(class)实例方法当前实例(this)修饰代码块指定变量synchronized锁膨胀过程 [偏向锁] -&gt; [轻量级锁] -&gt; [重量级锁]偏向锁偏向锁会在第一次进行同步访问时的将访问线程的线程ID使用CAS记录到互斥变量的Mark word。以后每次访问则检查访问线程的ID是否等于Mark word中记录的线程ID，如果等于则可以无锁同步。如果线程ID不相同则说明有其他线程竞争，此时偏向锁会膨胀成轻量级锁适用场景：自始至终仅有同一线程访问优点：可以实现无锁同步缺点：如果很明显有其他线程竞争则很快将膨胀成轻量级锁轻量级锁加锁：为访问线程创建Lock record，将锁对象的Mark word复制到Lock record称为Displaced mark word，尝试使用CAS将Mark word指向Displaced mark word，如果成功则获取锁成功，否则循环重试解锁：使用Displaced mark word替换原对象的Mark word轻量级锁会在重试次数过多时膨胀成重量级锁适用场景：线程竞争少，非耗时操作优点：可以避免线程阻塞造成的造成的用户态和内核态切换成本缺点：如果进行耗时操作则会循环获取锁占用CPU资源重量级锁重量级锁会在利用操作系统底层创建互斥量实现，同步时会造成内核态切换适用场景：线程竞争激烈，耗时操作优点：线程直接阻塞无CPU资源占用缺点：线程阻塞，阻塞和唤醒线程耗时可能会超过代码本身执行时间，性能可能低于轻量级锁ReentrantLock锁ReentrantLock分为公平锁和非公平锁，内部使用CAS方式实现具体原理类似于轻量级锁对比synchronizedjava关键字，易用无需改代码享受jdk优化ReentrantLockjava类，加锁解锁都是实例方法，可以更灵活的控制提供Condition可以灵活的控制要唤醒的线程可以实现公平锁可以中断等待","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https//raylax.github.io/tags/并发/"}]},{"title":"java并发-volatile关键字","slug":"java/concurrent-volatile-keyword","date":"2019-01-24T06:16:31.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/concurrent-volatile-keyword.html","link":"","permalink":"https//raylax.github.io/post/java/concurrent-volatile-keyword.html","excerpt":"","text":"引言前一篇文章讲了java内存模型相关概念，线程在工作的时候会从主内存中复制数据到工作内存中进行操作，这样多线程情况下就会出现数据一致性问题，使用volatile关键字则可以避免此问题。作用如果使用volatile关键字修饰一个类的(静态)成员变量，则有两种作用确保了多线程对此变量的可见性每次获取变量会强制从主内存获取，每次修改变量后会立即刷新到主内存禁止进行指令重排(java虚拟为了优化执行效率会进行指令重排，暂不详细说明)volatile可以保证原子性么volatile仅能确保每次获取的数据都是最新的数据，并不能保证原子性12345678910111213141516171819202122public class VolatileTest &#123; private volatile int count = 0; public static void main(String[] args) throws Exception &#123; VolatileTest v = new VolatileTest(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(10); // 创建10个线程 for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(() -&gt; &#123; // 每个线程增加10000 for (int j = 0; j&lt; 10000; j++) &#123; v.count++; &#125; &#125;)); &#125; // 启动 threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(v.count); &#125;&#125;结果应该是100000，实际上这段代码运行结果并不是100000，因为count++操作不是一个原子操作，++操作会先获取count变量然后对其加一刷新到主内存多线程情况下可能多个线程同时获取了该变量对其操作然后刷新到主内存。例如数据是5，2条线程同时获取了该变量对其+1，同时将6刷新到主内存，这时主内存的数据是6但我们期望的是7要解决这个问题可以用synchronized和ReentrantLock对要操作的数据加同步锁解决此问题synchronized解决方式synchronized方式通过java内置字节码指令monitorenter和monitorexit实现的123456789101112131415161718192021222324252627public class VolatileTest &#123; private volatile int count = 0; private volatile Object countMutex = new Object(); public static void main(String[] args) throws Exception &#123; VolatileTest v = new VolatileTest(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(10); // 创建10个线程 for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(() -&gt; &#123; // 每个线程增加10000 for (int j = 0; j&lt; 10000; j++) &#123; // 加锁 synchronized (v.countMutex) &#123; v.count++; &#125; &#125; &#125;)); &#125; // 启动 threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(v.count); &#125;&#125;`ReentrantLock解决方式ReentrantLock方式通过CAS方式实现123456789101112131415161718192021222324252627public class VolatileTest &#123; private volatile int count = 0; public static void main(String[] args) throws Exception &#123; VolatileTest v = new VolatileTest(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(10); ReentrantLock lock = new ReentrantLock(); // 创建10个线程 for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(() -&gt; &#123; // 每个线程增加10000 for (int j = 0; j&lt; 10000; j++) &#123; // 加锁 lock.lock(); v.count++; lock.unlock(); &#125; &#125;)); &#125; // 启动 threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(v.count); &#125;&#125;`","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https//raylax.github.io/tags/并发/"}]},{"title":"java-内存模型","slug":"java/memory-model","date":"2019-01-23T02:20:33.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/memory-model.html","link":"","permalink":"https//raylax.github.io/post/java/memory-model.html","excerpt":"","text":"引言计算机程序每条指令都由CPU执行，执行过程中会对数据进行操作，程序运行时的临时数据都储存在内存中。但是CPU执行指令的速度远远大于内存读取/写入速度，如果每次操作都需要对内存进行一次操作会大幅度降低CPU运行速度，所以CPU引入高速缓存(L1/L2/L3)来提高读写速度，如果需要对某条数据进行操作，CPU会从内存中复制数据到高速缓存中，然后对其进行一系列操作操作，结束后刷新到内存里。引入高速缓存很好的解决了CPU执行的效率问题，但引发了一致性问题，即在多核心状态下，每个核心都有自己的高速缓存，无法保证同一数据不同核心下的高速缓存是一致的。CPU通过缓存一致性协议来解决了这个问题，例如Intel MESI协议，这里不做过多说明。Java虚拟机中定义了一种类似的Java内存模型，来屏蔽各硬件平台和操作系统之间的差异以及提高程序运行效率。内存模型堆内存共享区域java虚拟机管理的最大内存区域，几乎所有的对象都会在此区域分配。在需要时自行扩展，可以通过-Xmx|-Xms来控制大小，当此区域内存回收后无法为新对象分配空间且无法扩展，则会抛出OutOfMemoryError异常方法区共享区域用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。栈内存线程私有用于存储局部变量表、操作栈、动态链接、方法出口等信息。该区域内存用尽会抛出StackOverFlow异常，常见于递归操作，可以通过-Xss参数来调解栈内存大小本地方法区线程私有为Native方法服务，规范中并未明确定义数据结构和使用方式程序计数器线程私有用于记录当前执行的字节码的行号，java虚拟机利用计数器来实现循环、跳转以及线程切换恢复执行。使用nio分配堆外内存暂不说明运行机制所有对象都储存在主内存中，不包括局部变量和方法参数，局部变量与方法参数是线程私有的。每个线程还有自己的工作内存，类似于CPU的高速缓存。当每个线程工作时会从主内存中拷贝一份数据到工作内存，在工作内存进行操作，操作完成后才会刷新到主内存中。","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]},{"title":"Spring-bean管理","slug":"java/spring-bean","date":"2019-01-22T10:01:56.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/spring-bean.html","link":"","permalink":"https//raylax.github.io/post/java/spring-bean.html","excerpt":"","text":"前言Spring中所有的bean都由IoC容器管理，IoC容器负责创建/销毁bean，Spring中的IoC容器即BeanFactory，BeanFactory为一个接口，Srping中所有的ApplicationContext都实现了此接口。作用域Spring中定义了4种bean的作用域以适应不同业务场景作用域描述singleton单例方式存在，只创建一个实例，每次获取都返回该实例(默认)prototype每次获取都创建一个新实例request同一请求下每次获取实例都返回同一个实例(仅限于WebApplicationContext)session同一会话下每次获取实例都返回同一个实例(仅限于WebApplicationContext)其中后两者是只有在web环境下才生效的，基于WebApplicationContext生命周期singleton容器时启动创建，随容器关闭而销毁，可以设置@Lazy注解使其在第一次获取时创建prototype该作用域的实例Spring并不负责管理生命周期request随每个请求创建/销毁session随每个会话创建/销毁生命周期监控Spring管理的bean的生命周期可以使用一系列接口/注解来监控bean的生命周期实例级监控InitializingBean#afterPropertiesSet在bean初始化成功后调用DiposableBean#destroy在bean销毁前调用@PostConstruct该注解修饰的方法会在bean创建后调用@PreDestroy该注解修饰的方法会在bean销毁前调用@PostConstruct修饰的方法先于InitializingBean#afterPropertiesSet执行@PreDestroy修饰的方法先于DiposableBean#destroy执行容器级监控BeanPostProcessor#postProcessBeforeInitialization方法会在bean初始化前调用，先于@PostConstruct|InitializingBean#afterPropertiesSet执行BeanPostProcessor#postProcessAfterInitialization方法会在bean初始化前调用，后于@PostConstruct|InitializingBean#afterPropertiesSet执行图片描述上面这张图完整描述了bean的生命周期(图片来源于网络)","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https//raylax.github.io/tags/spring/"}]},{"title":"MySQL-事务隔离级别","slug":"mysql-transaction-isolation","date":"2019-01-21T06:18:25.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/mysql-transaction-isolation.html","link":"","permalink":"https//raylax.github.io/post/mysql-transaction-isolation.html","excerpt":"","text":"事务ACID特性原子性(Atomicity)一个事物内的所有操作视为一个不可分割的操作，事务内所有操要么全执行成功要么全失败例如：一个事务内A给B转账，先从A账户中扣钱，然后向B账户中加对应的钱数，这两次数据库操作要么全成功要么全失败，不能某个操作成功了，其他的失败了一致性(Consistency)一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少(摘自百度)例如：一共有2个账户，这些账户的总余额为100，无论如何进行并发操作最终这2个账户的余额的和必须为100隔离性(Isolation)隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作持久性(Durability)在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚事务隔离级别完全隔离是不现实的，因为完全隔离会使事务串行化，严重影响并发性能，所以引入隔离级别来控制并发访问MySQl支持4中隔离级别隔离级别描述读未提交(read uncommitted)一个事务可以读其他事务未提交的数据读已提交(read committed)一个事务只能读其他事务已提交的数据可重复读(repeatable read)一个事务内多次读同一数据必须一致(MySQL默认隔离级别)串行化(serializable)事务串行化，同一个表同时只能有一个事务进行操作并发引发问题脏读A事务读取了B事务未提交的数据并在此基础上进行操作，结果B事务回滚了，那么A所进行的操作就是有问题的不可重复读不可重复读指同一事务中两次读取的数据不一致，A事务读取了一条数据，B事务修改了数据并且提交了，A事务又读了此条数据结果与上一读取的数据不一致幻读事务A统计了数据量，事务B添加了N条记录，事务B又查了一次，结果两次结果数量不一致隔离级别对应问题隔离级别越往下并发效率越低，可重复读行级锁，串行化表级锁级别\\问题脏读不可重复读幻读读未提交(read uncommitted)xxx读已提交(read committed)√xx可重复读(repeatable read)√√x串行化(serializable)√√√总结只有InnoDB引擎支持事务并且支持行级锁，MyISAM引擎并不支持事务且仅支持表级锁InnoDB适合频繁update业务场景(交易系统)，MyISAM适用于大量select、insert业务场景(日志类系统)处理数据库并发问题并非只能依靠数据来处理，可以结合代码进行合理的加锁，例如依靠外部redis/zookeeper做分布式锁","categories":[{"name":"database","slug":"database","permalink":"https//raylax.github.io/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https//raylax.github.io/tags/mysql/"}]},{"title":"Spring-事物传播方式/机制","slug":"java/spring-transaction","date":"2019-01-20T10:55:03.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/spring-transaction.html","link":"","permalink":"https//raylax.github.io/post/java/spring-transaction.html","excerpt":"","text":"概述Spring在org.springframework.transaction.TransactionDefinition中定义了七中事物传播方式，规定了需要执行事物的方法和事物发生嵌套时如何进行传播传播方式描述PROPAGATION_REQUIRED支持当前事务，如果没有事务则创建一个事务PROPAGATION_SUPPORTS支持当前事务，如果没有事务则已非事务方式执行PROPAGATION_MANDATORY支持当前事务，如果没有事务则抛异常PROPAGATION_REQUIRES_NEW创建新事务，如果已存在事务则挂起PROPAGATION_NOT_SUPPORTED不支持当前事务，如果存在则以非事务方式执行PROPAGATION_NEVER不支持当前事务，如果存在则抛出异常PROPAGATION_NESTED如果当前存在事务则执行嵌套事务，否则以类似PROPAGATION_REQUIRED方式执行详解除了PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED其他都很好理解，主要解释下这两者的区别PROPAGATION_REQUIRES_NEW创建一个独立的”内部”事务，挂起原有事务，此事务与原事务互不依赖1234567891011121314151617181920// UserServiceAImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void addUser(UserEntity user) &#123; logger.info(\"UserServiceAImpl#addUser begin\"); userRepository.save(user); userServiceB.updateUser(user); logger.info(\"UserServiceAImpl#addUser complete\");&#125;// UserServiceBImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void updateUser(UserEntity user) &#123; logger.info(\"UserServiceBImpl#updateUser begin\"); userRepository.save(user); logger.info(\"UserServiceBImpl#updateUser complete\");&#125;// Test.javaUserEntity user = new UserEntity(\"raylax\");userServiceA.addUser(user);截取部分运行日志12345678910111213141516171819202122232425262728293031# 创建事务Creating new transaction with name [UserServiceAImpl.addUser]: PROPAGATION_REQUIRED,ISOLATION_DEFAULTOpened new EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transactionExposing JPA transaction as JDBC [HibernateConnectionHandle@580902cd]# 进入addUser方法UserServiceAImpl#addUser beginFound thread-bound EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transactionParticipating in existing transactionFound thread-bound EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transaction# 挂起当前事务Suspending current transaction, creating new transaction with name [UserServiceBImpl.updateUser]# 创建新事务Opened new EntityManager [SessionImpl(40626598&lt;open&gt;)] for JPA transactionExposing JPA transaction as JDBC [HibernateConnectionHandle@4d518c66]# 进入updateUser方法UserServiceBImpl#updateUser beginFound thread-bound EntityManager [SessionImpl(40626598&lt;open&gt;)] for JPA transactionParticipating in existing transaction# 退出updateUser方法UserServiceBImpl#updateUser complete# 提交新事务Initiating transaction commitCommitting JPA transaction on EntityManager [SessionImpl(40626598&lt;open&gt;)]Closing JPA EntityManager [SessionImpl(40626598&lt;open&gt;)] after transaction# 恢复被挂起的事务Resuming suspended transaction after completion of inner transaction# 退出addUser方法UserServiceAImpl#addUser complete# 提交原事务Initiating transaction commitCommitting JPA transaction on EntityManager [SessionImpl(254041053&lt;open&gt;)]PROPAGATION_NESTED如果当前存在事务则执行嵌套事务，否则以类似PROPAGATION_REQUIRED方式执行嵌套事务创建同时会创建一个savepoint如果该事务发生异常会回滚到savepoint嵌套事务会跟随父事务commit/rollbackNESTED需要基于JDBC3.0并且事务支持savepoint1234567891011121314151617181920// UserServiceAImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void addUser(UserEntity user) &#123; logger.info(\"UserServiceAImpl#addUser begin\"); jdbcTemplate.execute(\"insert into t_user values(1, '\" + user.getName() + \"')\"); userServiceB.updateUser(user); logger.info(\"UserServiceAImpl#addUser complete\");&#125;// UserServiceBImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void updateUser(UserEntity user) &#123; logger.info(\"UserServiceBImpl#updateUser begin\"); jdbcTemplate.update(\"update t_user set name = '\" + user.getName() + \"-updated'\"); logger.info(\"UserServiceBImpl#updateUser complete\");&#125;// Test.javaUserEntity user = new UserEntity(\"raylax\");userServiceA.addUser(user);截取部分运行日志123456789101112131415161718192021# 创建事务Acquired Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] for JDBC transactionSwitching JDBC Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] to manual commit# 进入addUser方法UserServiceAImpl#addUser beginExecuting SQL statement [insert into t_user values(1, &apos;raylax&apos;)]# 创建嵌套事务，创建保存点Creating nested transaction with name [UserServiceBImpl.updateUser]# 进入updateUser方法UserServiceBImpl#updateUser beginExecuting SQL update [update t_user set name = &apos;raylax-updated&apos; where id = null]# 退出updateUser方法UserServiceBImpl#updateUser complete# 释放保存点Releasing transaction savepoint# 退出addUser方法UserServiceAImpl#addUser complete# 提交事务，嵌套事务会跟随提交Initiating transaction commitCommitting JDBC transaction on Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a]Releasing JDBC Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] after transaction注意事项事务默认以PROPAGATION_REQUIRED方式执行事务传播的控制基于AOP，所以只有调用spring管理的实例方法时生效，调用this指向方法不生效例如ClassA调用methodA，methodA中调用了ClassB的methodB此时传播控制才生效如ClassA调用methodA，methodA中调用调用了内部的methodB则会以PROPAGATION_REQUIRED方式执行，传播控制不生效生效示例12345678910// ClassA.javapublic void methodA() &#123; classB.methodB();&#125;// ClassB.javapublic void methodB() &#123;&#125;// Test.javaclassA.methodA();不生效示例123456789// ClassA.javapublic void methodA() &#123; methodB();&#125;public void methodB() &#123; &#125;// Test.javaclassA.methodA();","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https//raylax.github.io/tags/spring/"}]},{"title":"JAVA-JDK和CGLIB动态代理使用","slug":"java/jdk-proxy-cglib-proxy-use","date":"2019-01-20T10:50:33.000Z","updated":"2021-01-20T10:23:11.096Z","comments":true,"path":"post/java/jdk-proxy-cglib-proxy-use.html","link":"","permalink":"https//raylax.github.io/post/java/jdk-proxy-cglib-proxy-use.html","excerpt":"","text":"代理模式代理模式即给某一对象生成一个代理对象，来对原对象进行一些访问控制通过代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部应用场景鉴权、事物、日志、异常处理…静态代理优点：面向接口编程屏蔽内部实现，如需修改实现类直接修改代理类即可缺点：每个代理类只能为一个接口服务，需要为每个接口创建代理。实现类与代理类都实现了相同的接口，如增加一个方法所有代理类都需要进行修改，增加了维护的复杂度1234567891011121314151617181920212223242526272829interface Person &#123; void doAction();&#125;class RealPerson implements Person &#123; @Override public void doAction() &#123; System.out.println(\"do action !\"); &#125;&#125;class ProxyPerson implements Person &#123; private Person person = new RealPerson(); @Override public void doAction() &#123; System.out.println(\"method start\"); try &#123; person.doAction(); System.out.println(\"method complete\"); &#125; catch (Exception e) &#123; System.out.println(\"method error\"); &#125; &#125;&#125;public void call() &#123; Person person = new ProxyPerson(); person.doAction();&#125;JDK动态代理需要用到的类java.lang.reflect.InvocationHandler和java.lang.reflect.ProxyProxy为原对象的代理对象InvocationHandler#invoke方法会在代理对象被调用时调用，可以在此处做处理Proxy#newProxyInstance方法的第二个参数必须为接口，所以JDK动态代理只能为实现了接口的类生成代理123456789101112131415161718192021222324252627282930313233343536373839404142interface Person &#123; void doAction();&#125;class RealPerson implements Person &#123; @Override public void doAction() &#123; System.out.println(\"do action !\"); &#125;&#125;class ProxyClass implements InvocationHandler &#123; private Object realObject; ProxyClass(Object realObject) &#123; this.realObject = realObject; &#125; public Object newProxy() &#123; // 生成代理对象 return Proxy.newProxyInstance( realObject.getClass().getClassLoader(), realObject.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"method start\"); try &#123; // 使用反射调用原对象方法 Object result = method.invoke(realObject, args); System.out.println(\"method complete\"); return result; &#125; catch (Exception e) &#123; System.out.println(\"method error\"); throw e; &#125; &#125;&#125;public void call() &#123; Person person = (Person) new ProxyClass(new RealPerson()).newProxy(); person.doAction();&#125;CGLib动态代理CGLib动态代理底层采用ASM字节码生成框架，使用字节码技术生成代理类，原理是生成目标类的子类。CGLib可以为未实现接口的类生成代理，但无法为final类生成代理123456789101112131415161718192021222324252627282930313233class RealPerson &#123; public void doAction() &#123; System.out.println(\"do action !\"); &#125;&#125;class ProxyClass implements MethodInterceptor &#123; public Object newProxy(Class clazz) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"method start\"); try &#123; // 调用父类方法 Object result = proxy.invokeSuper(obj, args); System.out.println(\"method complete\"); return result; &#125; catch (Exception e) &#123; System.out.println(\"method error\"); throw e; &#125; &#125;&#125;public void call() &#123; RealPerson person = (RealPerson) new ProxyClass().newProxy(RealPerson.class); person.doAction();&#125;","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]}]}