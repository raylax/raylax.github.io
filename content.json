{"meta":{"title":"raylax","subtitle":null,"description":null,"author":"raylax","url":"https//raylax.github.io"},"pages":[{"title":"","date":"2021-02-22T13:34:51.509Z","updated":"2021-02-22T13:34:51.509Z","comments":false,"path":"categories/index.html","permalink":"https//raylax.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-22T13:34:51.509Z","updated":"2021-02-22T13:34:51.509Z","comments":false,"path":"tags/index.html","permalink":"https//raylax.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java HashMap源码之树化","slug":"java/hashmap-treeify","date":"2021-02-22T06:17:28.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/hashmap-treeify.html","link":"","permalink":"https//raylax.github.io/post/java/hashmap-treeify.html","excerpt":"","text":"hashmap会在hash冲突达到特定阈值之后将链表转换成红黑树TreeNode&lt;K, V&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 查找根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; // 将根节点设置为table相对应的位置 static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; // 计算index int index = (n - 1) &amp; root.hash; // 原链表头结点 TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; // 如果原链表头结不等于根节点 if (root != first) &#123; // 后继节点 Node&lt;K,V&gt; rn; // 将根节点放入table tab[index] = root; // root的前驱节点 TreeNode&lt;K,V&gt; rp = root.prev; // 如果root存在后继节点，则将他的前驱节点设置为root的前驱节点 if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; // 如果root存在前驱节点，则将他的后继节点设置为root的后继节点 if (rp != null) rp.next = rn; // 如果原始节点存在 if (first != null) first.prev = root; // 将根节点的后继节点设置为原始节点 root.next = first; // 将根节点的前置节点设置为null root.prev = null; &#125; // 验证红黑树准确性 assert checkInvariants(root); &#125; &#125; // 查找 // h = hash value // k = key // kc = key class final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; // 当前节点 do &#123; int ph; // hash值 int dir; // 方向 K pk; // key TreeNode&lt;K,V&gt; pl = p.left; // 左子节点 TreeNode&lt;K,V&gt; pr = p.right; // 右子节点 TreeNode&lt;K,V&gt; q; // 要找的对象 // 如果当前节点的hash值大于要找的hash值则让左子节点进行下一轮查找 if ((ph = p.hash) &gt; h) p = pl; // 如果当前节点的hash值小于要找的hash值则让右子节点进行下一轮查找 else if (ph &lt; h) p = pr; // 如果hash值相等并且key值相等，说明找到了，直接返回 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; // 如果hash值相等并且左子节点为空让右子节点进行下一轮查找 else if (pl == null) p = pr; // 如果hash值相等并且右子节点为空让左子节点进行下一轮查找 else if (pr == null) p = pl; // 使用comparable接口进行比较来选择向左还是右查找 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; // 如果comparable比较后还是相等则使用右子树进行递归查找 else if ((q = pr.find(h, k, kc)) != null) return q; // 如果右子树查找不到，则使用左子树进行下一轮查找 else p = pl; &#125; while (p != null); return null; &#125; // 获取key所在的node final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; // 比较两个对象返回-1或1 static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; // 树化 final void treeify(Node&lt;K,V&gt;[] tab) &#123; // 根节点 TreeNode&lt;K,V&gt; root = null; // 遍历链表，x指向当前节点，next指向下一个节点 for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; // 如果还没有根节点 x.parent = null; // 设置父节点为空 x.red = false; // 设置为黑色 root = x; // 将当前节点设置为根节点 &#125; else &#123; K k = x.key; // 当前节点的key int h = x.hash; // 当前节点的hash Class&lt;?&gt; kc = null; // 当前key的class for (TreeNode&lt;K,V&gt; p = root;;) &#123; // 从根节点遍历 int dir; // 方向 int ph; // p hash K pk = p.key; // p key // 如果p hash大于当前节点的hash设置dir为-1表示向左插入 if ((ph = p.hash) &gt; h) dir = -1; // 如果p hash小于当前节点的hash设置dir为1表示向右插入 else if (ph &lt; h) dir = 1; // 如果相等，使用comparable接口比较 else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) // 如果comparable接口比较还是相等 dir = tieBreakOrder(k, pk); // 保存p节点 TreeNode&lt;K,V&gt; xp = p; // 如果dir小于0一定放入当前节点的左侧 // 如果dir大于0一定放入当前节点的右侧 // 如果要插入的左侧节点为null或者要插入的右侧节点为null，执行插入逻辑 // 否则将p设置为left或者right进行下一次循环 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; // 当前节点的父节点设置为p x.parent = xp; // 如果小于0，设置为左子节点 if (dir &lt;= 0) xp.left = x; // 如果大于0，设置为右子节点 else xp.right = x; // 执行红黑树平衡插入并且重新设置root root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; // 将root节点设置到table moveRootToFront(tab, root); &#125; // 取消树化 final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null; // 链表头 Node&lt;K,V&gt; tl = null; // 链表尾 // 遍历链表 for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; // 将treenode转换成普通node Node&lt;K,V&gt; p = map.replacementNode(q, null); // 如果链表尾没初始化将头设置为当前节点 if (tl == null) hd = p; // 如果已经初始化将当前节点拼接到链表尾 else tl.next = p; // 将链表尾设置为当前节点 tl = p; &#125; // 返回链表头 return hd; &#125; /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by \"next\" pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || (movable &amp;&amp; (root.right == null || (rl = root.left) == null || rl.left == null))) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]},{"title":"Java HashMap源码","slug":"java/hashmap","date":"2021-02-21T06:17:28.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/hashmap.html","link":"","permalink":"https//raylax.github.io/post/java/hashmap.html","excerpt":"","text":"常量123456789101112// 默认初始容量2^4，必须为2的N次方static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// 最大容量2^30static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认扩容因子，当容量达到75%时进行扩容static final float DEFAULT_LOAD_FACTOR = 0.75f;// 树化阈值，当链表长度&gt;=8时将链表转换成红黑树 static final int TREEIFY_THRESHOLD = 8;// 链表化阈值，当红黑树节点数量&lt;=6时将红黑树转换成链表static final int UNTREEIFY_THRESHOLD = 6;// 最小树化阈值，只有map容量大于此值才进行链表树化，否则直接扩容static final int MIN_TREEIFY_CAPACITY = 64; // 不能小于 4 * TREEIFY_THRESHOLD变量12345678910// 存放数据的数组transient Node&lt;K,V&gt;[] table;// entity集合transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// 大小transient int size;// 扩容阈值，大于阈值将进行扩容int threshold; // 容量 * 扩容因子// 扩容因子final float loadFactor;构造函数123456789101112131415public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // 如果初始容量大于最大容量则初始容量等于最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // 扩容因子 this.loadFactor = loadFactor; // 扩容阈值 this.threshold = tableSizeFor(initialCapacity);&#125;Node12345678910static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 节点hash值 final int hash; // key final K key; // value V value; // 链表下一个节点 Node&lt;K,V&gt; next;&#125;tableSizeFor(int cap)返回大于等于输入参数且最近的2的整数次幂的数1234567891011121314// 规定table数组的长度必须为2的n次方// 2的n次方的数的特点为第n位为1其他均为0// -1操作会使第1-(n-1)位全为1// 假如cap的二进制位01xxxxxx// 则大于等于cap且最近的2的整数次幂的数的二进制为10xxxxxxstatic final int tableSizeFor(int cap) &#123; int n = cap - 1; // 假设n=1xxxxx n |= n &gt;&gt;&gt; 1; // n = 1xxxxx | 01xxxx = 11xxxx n |= n &gt;&gt;&gt; 2; // n = 11xxxx | 0011xx = 1111xx n |= n &gt;&gt;&gt; 4; // n = 1111xx | 000011 = 111111 n |= n &gt;&gt;&gt; 8; // n = 111111 | 000000 = 111111 n |= n &gt;&gt;&gt; 16; // n = 111111 | 000000 = 111111 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; // +1得出最终的cap&#125;put(K key, V value)向map放入key-value123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;hash(Object key)12345678910// 计算hash值static final int hash(Object key) &#123; int h; // 如果key为null则hash值为0 // 否则调用key的hashCode方法获取hash值 // 然后与其高16位进行异或返回 // 这样做的原因是当数组很短的时候只有低位参与了运算 // 让高十六位特征参与运算会更好的减少散列冲突 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @param hash hash值 * @param key key * @param value value * @param onlyIfAbsent 如果是true则不改变已有值 * @param evict 如果是false则为创建模式 * @return 返回改变之前的值 */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; // 局部变量table Node&lt;K,V&gt; p; // 原始node int n; // table长度 int i; // node在table中的位置 // 判断table是否等于null或者为空 // 如果为空则进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 对hash值进行取模得到i // 当hash为2的次幂，x % hash == x &amp; (hash - 1) // 位运算效率远远高于取模运算，所以这里使用位运算代替取模 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果没有原始值，则new一个新node放入table tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; // 已存在节点e K k; // 已存在节点的key if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果hash值相等并且key相等 e = p; else if (p instanceof TreeNode) // 如果p是一个红黑树则放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // hash冲突情况，遍历链表 for (int binCount = 0; ; ++binCount) &#123; // 如果到链表尾，将节点添加到链表尾 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果链表长度大于等于阈值则进行树化 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果hash值相等并且key相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 设置p为当前链表节点 p = e; &#125; &#125; // 判断是否存在旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 改变旧值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; ++modCount; // 如果长度大于阈值则进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125;resize()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果旧容量大于0 if (oldCap &gt; 0) &#123; // 如果旧容量大于等于最大容量，将扩容阈值改为int最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 新容量等于旧容量x2 // 如果新容量小于最大容量，新阈值等于旧阈值*2 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 如果旧阈值大于0，设置容量为阈值 else if (oldThr &gt; 0) newCap = oldThr; // 默认容量和阈值 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新阈值为0计算新阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 设置新阈值 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) // 创建新table Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 遍历旧table for (int j = 0; j &lt; oldCap; ++j) &#123; // 当前节点 Node&lt;K,V&gt; e; // 如果旧table里的node不为null if ((e = oldTab[j]) != null) &#123; // 将旧table的node设置为null oldTab[j] = null; // 如果没有后继节点（即没有hash冲突） // 将当前节点放入新的table if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果当前节点是红黑树，将红黑树拆分放入新的table else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 如果有后继节点的情况（即有hash冲突） Node&lt;K,V&gt; loHead = null; Node&lt;K,V&gt; loTail = null; Node&lt;K,V&gt; hiHead = null; Node&lt;K,V&gt; hiTail = null; // 下一个节点 Node&lt;K,V&gt; next; do &#123; // 将next设置为当前节点的下一个节点 next = e.next; // 如果扩容后index在原来的位置 if ((e.hash &amp; oldCap) == 0) &#123; // 如果是初始状态，将当前节点设置为loHead if (loTail == null) loHead = e; // 如果不是初始状态，将当前节点拼接到链表上 else loTail.next = e; // 设置loTail为当前节点 loTail = e; &#125; // 如果扩容后index不在原来的位置 else &#123; // 同上 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 将扩容后未改变index的元素复制到新数组 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 将扩容后改变了index位置的元素复制到新数组 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125;(e.hash &amp; oldCap) == 0用来判断扩容后的index是否改变假设capacity=8、threshold=6，在添加第7个元素时进行扩容12345678910111213141516171819202122232425# 容量capacity = 8# 扩容阈值threshold = 6# 碰撞的indexindex = 5# 碰撞的hashkeys = [13, 21, 29, 37, 45, 53, 61]# 根据index = hash &amp; (n - 1)# cap - 1 = 8 - 1 = 0b00001000 - 1 = 0b00000111# newCap - 1 = 8 - 1 = 0b00010000 - 1 = 0b00001111# 可知当cap=8时index由后3位决定，当cap=16时index由后4位决定# 想要判断index是否改变仅需要判断第4位是否为1，因为0xxx &amp; 0111 == 0xxx &amp; 1111# hash bin index(cap=8) index(cap=16) &amp;8# -----------------------------------------------------# 13 0b001101 0b0101=5 0b1101=13 0b1000# 21 0b010101 0b0101=5 0b0101= 5 0b0000# 29 0b011101 0b0101=5 0b1101=13 0b1000# 37 0b100101 0b0101=5 0b0101= 5 0b0000# 45 0b101101 0b0101=5 0b1101=13 0b1000# 53 0b110101 0b0101=5 0b0101= 5 0b0000# 61 0b111101 0b0101=5 0b1101=13 0b1000# 如果&amp;8不等于0，计算新index也很简单+0b1000(即旧cap)即可","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]},{"title":"js实现context menu","slug":"js/js-context-menu","date":"2021-02-01T13:33:43.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/js/js-context-menu.html","link":"","permalink":"https//raylax.github.io/post/js/js-context-menu.html","excerpt":"","text":"各种变量解释clientX相对于浏览器窗口的XclientY相对于浏览器窗口的YoffsetX相对于触发事件元素的XoffsetY相对于触发事件元素的YoffsetWidth元素宽度（包括边框）offsetHeight元素高度（包括边框）代码JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function ContentMenu(parent) &#123; this.menus = [] const add = (name, handler) =&gt; &#123; this.menus.push(&#123; name, handler, &#125;) &#125; const removeWrapper = () =&gt; &#123; if (this.wrapper) &#123; document.body.removeChild(this.wrapper) this.wrapper = null &#125; &#125; const createWrapper = () =&gt; &#123; const wrapper = document.createElement('ul') wrapper.id = 'cm-' + new Date().getTime() wrapper.className = 'cm-wrapper' wrapper.style.opacity = '0' for (let &#123; name, handler &#125; of this.menus) &#123; let menu = document.createElement('li'); menu.addEventListener('click', () =&gt; &#123; removeWrapper() handler.call(this.menus) &#125;, false) menu.innerText = name wrapper.appendChild(menu) &#125; return wrapper &#125; parent.oncontextmenu = (event) =&gt; &#123; event.preventDefault() let &#123; clientX, clientY, offsetX, offsetY &#125; = event // 创建content wrapper const wrapper = createWrapper() // 因为wrapper为fixed所以可以直接设置left和top为clientX和clientY wrapper.style.left = clientX + 'px' wrapper.style.top = clientY + 'px' // 删除原有元素 removeWrapper() // 添加到body document.body.appendChild(wrapper) this.wrapper = wrapper // 处理右边界，如果元素内X偏移+本身context宽度大于元素本身宽度 if (offsetX + wrapper.offsetWidth &gt; parent.offsetWidth) &#123; wrapper.style.left = (clientX - wrapper.offsetWidth) + 'px' &#125; // 处理下边界，如果元素内Y偏移+本身context高度大于元素本身高度 if (offsetY + wrapper.offsetHeight &gt; parent.offsetHeight) &#123; wrapper.style.top = (clientY - wrapper.offsetHeight) + 'px' &#125; // 因为wrapper的offsetHeight只有在渲染过才能取到，所以在创建时设置成透明 // 待所有属性都计算完成再显示 wrapper.style.opacity = '1' &#125; return &#123; add, &#125;&#125;const cm = new ContentMenu(document.getElementById('xxx'))cm.add('create', () =&gt; alert('create'))cm.add('update', () =&gt; alert('update'))cm.add('delete', () =&gt; alert('delete'))CSS123456789101112131415161718192021222324252627282930#xxx &#123; padding: 40px 30px 20px 10px; width: 600px; height: 400px; border: 1px solid #f00; position: fixed; left: 200px; top: 100px;&#125;.cm-wrapper &#123; list-style: none; margin-block: 0; padding-inline: 0; width: 120px; padding: 6px; background-color: #eee; border-radius: 3px; color: #333; position: fixed;&#125;.cm-wrapper li &#123; position: relative; padding: 3px 6px; border-radius: 3px; cursor: pointer;&#125;.cm-wrapper li:hover &#123; background-color: #69c; color: #fff;&#125;","categories":[{"name":"js/es/ts","slug":"js-es-ts","permalink":"https//raylax.github.io/categories/js-es-ts/"}],"tags":[{"name":"js","slug":"js","permalink":"https//raylax.github.io/tags/js/"}]},{"title":"js源码分析之jsfuck","slug":"js/jsfuck","date":"2021-01-22T13:33:43.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/js/jsfuck.html","link":"","permalink":"https//raylax.github.io/post/js/jsfuck.html","excerpt":"","text":"简述jsfuck可以将js代码转换成以[]()!+六个字符组成的可执行代码例如alert(1)可以转换成(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]]原理本质上基于js的类型转换数组 =&gt; booleal因为数组是真值1所以使用!将数组转换成boolean类型为false数组 =&gt; 数字 +[N]当数组长度为0或者长度为1且N为空字符串，例如+[]、+[&#39;&#39;]，+[N]的值为0当数组长度为1且N为数字是，例如+[2]、+[&#39;9&#39;]，+[N]的值为N当数组长度大于0或数组第一个元素不是上述两种情况，例如+[1,2,3]、+[false]，+[N]的值为NaNboolean =&gt; 数字true/false转换为数字分别为1和0转换12345678910111213141516false = ![]true = !![]undefined = [][[]] // [][0] = undefinedNaN = +[![]] // +[false] = NaN0 = +[] // 01 = +!+[] // +!+0 = +!0 = +true = 12 = !+[]+!+[] // !+[] + !+[] = !0 + !0 = true + true = 210 = +[[+!+[]]+[+[]]] // +[[1]+[0]] = +['10'] = 10Array = []Number = +[] // 0String = []+[] // \"\" + \"\" = \"\"Boolean = ![] // falseFunction = [][\"filter\"] // 数组的filter方法run = [][\"filter\"][\"constructor\"]( CODE )() // 执行CODEeval = [][\"filter\"][\"constructor\"](\"return eval\")()( CODE ) // eval CODEwindow = [][\"filter\"][\"constructor\"](\"return this\")() // 返回window对象执行run[][&quot;filter&quot;]会获取数组的filter方法，[][&quot;filter&quot;][&quot;constructor&quot;]会返回filter方法的构造函数，js中所有的方法的构造函数都是Function2对象Function2的最后一个参数会被当做方法体执行所以[][&quot;filter&quot;][&quot;constructor&quot;]( &quot;console.log(1)&quot; )()会输出1eval &amp; windowFunction2执行的作用域是全局作用域所以[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()对于浏览器来说返回window，同理[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return eval&quot;)()( CODE )相当于返回return window.eval然后传递CODE执行[][&quot;filter&quot;]中非只能是filter，理论上只要数组支持的函数都可以。例如map，push，pop等都可以这里使用flat、filter函数是因为其中的字母都可以从true/false里直接获取解析通过上面的分析我们就可以把代码替换成相应的[]()!+组合例如官方示例alert(1)，可以拆解为a、l、e、r、t、(、1、)字符串和数字替换比较简单123456a = (false+\"\")[1] = (![]+([]+[]))[+!+[]]l = (false+\"\")[2] = (![]+([]+[]))[!+[]+!+[]]e = (true+\"\")[3] = (!![]+([]+[]))[!+[]+!+[]+!+[]]r = (true+\"\")[1] = (!![]+([]+[]))[+!+[]]t = (true+\"\")[0] = (!![]+([]+[]))[+[]]1 = = +!+[]括号等特殊字符需要从function的toString里获取，例如&quot;&quot; + [][&quot;flat&quot;]返回function flat() { [native code] }，可以从中获取小括号大括号第13个为小括号13可以通过拼接!+[]十三次实现，但是&quot;flat&quot;也需要替换12345// flatf = (![]+([]+[]))[+[]]l = (![]+([]+[]))[!+[]+!+[]]a = (![]+([]+[]))[+!+[]]t = (!![]+([]+[]))[+[]]最终flat为((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])括号12( = ([][\"flat\"]+\"\")[13] = ([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]) = ([][\"flat\"]+\"\")[14] = ([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]组合起来alert(1)为((![]+([]+[]))[+!+[]])+((![]+([]+[]))[!+[]+!+[]])+((!![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(+!+[])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])我们还需要利用上面讲到的[][&quot;flat&quot;][&quot;constructor&quot;]( CODE )()让他运行起来需要替换flat和constructor，其中很多字符已经转换过了，只需转换c，o，n，s，u12345c = ([][\"flat\"]+\"\")[3]o = ([][\"flat\"]+\"\")[27]n = ([][\"flat\"]+\"\")[19]s = (false+\"\")[3] = (![]+([]+[]))[!+[]+!+[]+!+[]]u = (true+\"\")[2] = (!![]+([]+[]))[!+[]+!+[]]constructor为(([][&quot;flat&quot;]+&quot;&quot;)[3])+(([][&quot;flat&quot;]+&quot;&quot;)[27])+(([][&quot;flat&quot;]+&quot;&quot;)[19])+((false+&quot;&quot;)[3])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][&quot;flat&quot;]+&quot;&quot;)[3])+((!![]+([]+[]))[+[]])+(([][&quot;flat&quot;]+&quot;&quot;)[27])+((!![]+([]+[]))[+!+[]])替换true/false/flat和数字(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])最终可执行代码为1[][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])][(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[!+[]+!+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+[]])+(([][((![]+([]+[]))[+[]])+((![]+([]+[]))[!+[]+!+[]])+((![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])](((![]+([]+[]))[+!+[]])+((![]+([]+[]))[!+[]+!+[]])+((!![]+([]+[]))[!+[]+!+[]+!+[]])+((!![]+([]+[]))[+!+[]])+((!![]+([]+[]))[+[]])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+(+!+[])+(([][(![]+([]+[]))[+[]]+(![]+([]+[]))[!+[]+!+[]]+(![]+([]+[]))[+!+[]]+(!![]+([]+[]))[+[]]]+([]+[]))[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]))()参考[1] MDN 真值[2] MDN Function[3] jsfuck","categories":[{"name":"js/es/ts","slug":"js-es-ts","permalink":"https//raylax.github.io/categories/js-es-ts/"}],"tags":[{"name":"js","slug":"js","permalink":"https//raylax.github.io/tags/js/"}]},{"title":"Java并发之AQS相关代码分析-Semaphore","slug":"java/aqs-semaphore","date":"2021-01-20T04:06:01.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/aqs-semaphore.html","link":"","permalink":"https//raylax.github.io/post/java/aqs-semaphore.html","excerpt":"","text":"方法123456// 构造方法public Semaphore(int permits, boolean fair);// 获取许可public void acquire() throws InterruptedException;// 释放许可public void release();源码分析构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125;// 基础同步器abstract static class Sync extends AbstractQueuedSynchronizer &#123; Sync(int permits) &#123; setState(permits); // 设置许可数量 &#125; final int getPermits() &#123; return getState(); // 获取许可数量 &#125; // 非公平获取共享状态 final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); // 获取可用许可数量 int remaining = available - acquires; // 计算剩余许可数量 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; // 如果剩余数量小于0或者CAS设置剩余数量成功返回剩余数量否则自旋 &#125; &#125; // 释放共享状态 protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); // 获取当前可用许可数量 int next = current + releases; // 计算释放后许可数量 if (next &lt; current) // 检查溢出 throw new Error(\"Maximum permit count exceeded\"); if (compareAndSetState(current, next)) // CAS设置新的许可数量 return true; &#125; &#125; // 减少许可数量 final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); // 获取当前可用许可数量 int next = current - reductions; // 计算减少后数量 if (next &gt; current) // 检查溢出 throw new Error(\"Permit count underflow\"); if (compareAndSetState(current, next)) // CAS设置减少后的数量 return; &#125; &#125; // 清空许可 final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125;&#125;// 非公平模式static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; // 尝试获取锁 protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125;// 公平模式static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; // 尝试获取锁 protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; // 如果有前置等待节点直接返回 if (hasQueuedPredecessors()) return -1; int available = getState(); // 获取可用许可数量 int remaining = available - acquires; // 计算剩余许可数量 if (remaining &lt; 0 || compareAndSetState(available, remaining)) // 如果剩余许可小于0或者CAS设置成功直接返回 return remaining; &#125; &#125;&#125;acquire调用AQS#acquireSharedInterruptibly(int arg)方法1234567891011121314151617181920212223242526272829303132333435// AbstractQueuedSynchronizerpublic final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 判断中断 if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) // 调用对应的Sync实现的tryAcquireShared方法 doAcquireSharedInterruptibly(arg); // 如果小于0说明没有获取到&#125;// AbstractQueuedSynchronizerprivate void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 添加到等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); if (p == head) &#123; // 如果前驱节点是头结点 int r = tryAcquireShared(arg); // 尝试获取锁 if (r &gt;= 0) &#123; // 如果获取成功 setHeadAndPropagate(node, r); // 设置当前节点为头结点 p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // 判断是否需要挂起 parkAndCheckInterrupt()) // 挂起线程等待唤醒 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); // 清理等待队列 &#125;&#125;releaseShared在CountDownLatch一章有讲以上所有未详细解释方法在前几章已经讲过","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"AQS","slug":"AQS","permalink":"https//raylax.github.io/tags/AQS/"}]},{"title":"Java并发之AQS相关代码分析-CountDownLatch","slug":"java/aqs-count-down-latch","date":"2021-01-17T15:06:01.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/aqs-count-down-latch.html","link":"","permalink":"https//raylax.github.io/post/java/aqs-count-down-latch.html","excerpt":"","text":"方法12345678// 构造方法public CountDownLatch(int count);// 释放public void countDown();// 等待public void await() throws InterruptedException;// 等待（带超时时间）public boolean await(long timeout, TimeUnit unit) throws InterruptedException源码分析构造方法123456789101112// CountDownLatchpublic CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count);&#125;// CountDownLatch.Syncprivate static final class Sync extends AbstractQueuedSynchronizer &#123; Sync(int count) &#123; // 设置state setState(count); &#125;&#125;countDown调用AQS#releaseShared(int arg)方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// AbstractQueuedSynchronizerpublic final boolean releaseShared(int arg) &#123; // 尝试释放共享资源 if (tryReleaseShared(arg)) &#123; // 如果全部释放完成唤醒等待队列 doReleaseShared(); return true; &#125; return false;&#125;// CountDownLatch.Syncprotected boolean tryReleaseShared(int releases) &#123; // 自旋 for (;;) &#123; // 获取当前状态 int c = getState(); // 如果释放完了直接返回 if (c == 0) return false; // 减一 int nextc = c-1; // 如果CAS设置不成功自旋 if (compareAndSetState(c, nextc)) return nextc == 0; // 如果等于0说明全部释放完成 &#125;&#125;// AbstractQueuedSynchronizerprivate void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // unparkSuccessor相关源码在ReentrantLock已经讲过 unparkSuccessor(h); // 如果是SIGNAL并且CAS设置初始状态成功则唤醒线程 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 如果是初始状态则设置状态为PROPAGATE continue; &#125; if (h == head) // 正常调用过unparkSuccessor后其他线程会竞争改变head，如果head没变跳出循环 break; &#125;&#125;await调用AQS#acquireSharedInterruptibly(int arg)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// AbstractQueuedSynchronizerpublic final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 如果线程被中断，抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); // 如果还有待释放的state值&#125;// CountDownLatch.Syncprotected int tryAcquireShared(int acquires) &#123; // 如果全部释放返回1否则返回-1 return (getState() == 0) ? 1 : -1;&#125;// AbstractQueuedSynchronizerprivate void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 添加到共享等待队列，相关源码在ReentrantLock已经讲过 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取当前节点的前驱节点 final Node p = node.predecessor(); // 如果前驱节点是头节点，再次尝试获取 if (p == head) &#123; int r = tryAcquireShared(arg); // &gt;=0 说明state==0 countdown结束 if (r &gt;= 0) &#123; // 设置当前节点为head并向后传播 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // 如果获取失败 if (shouldParkAfterFailedAcquire(p, node) // 判断是否可以挂起线程 &amp;&amp; parkAndCheckInterrupt()) // 挂起线程等待唤醒 throw new InterruptedException(); &#125; &#125; finally &#123; // 如果失败了则取消获取 if (failed) cancelAcquire(node); &#125;&#125;// AbstractQueuedSynchronizerprivate void setHeadAndPropagate(Node node, int propagate) &#123; // 保存原始head Node h = head; // 把当前节点设置为head setHead(node); // propagate &gt; 0 永远是true // 如果头节点是null或者waitStatus是有效地 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 如果后继节点是共享的释放共享锁 if (s == null || s.isShared()) doReleaseShared(); &#125;&#125;await(long timeout, TimeUnit unit)调用AQS#tryAcquireSharedNanos(int arg, long nanosTimeout)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// AbstractQueuedSynchronizerpublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 如果获取成功直接返回 return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout); // 超时等待&#125;// AbstractQueuedSynchronizerstatic final long spinForTimeoutThreshold = 1000L;private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; // 计算deadline final long deadline = System.nanoTime() + nanosTimeout; // 添加到等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // 尝试获取 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return true; &#125; &#125; // 重新计算超时时间 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) // 如果超过1000才会挂起线程，否则直接自旋 LockSupport.parkNanos(this, nanosTimeout); // 带超时挂起线程 // 如果中断抛出异常 if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; // 如果失败了则取消获取 if (failed) cancelAcquire(node); &#125;&#125;以上所有未详细解释方法在ReentrantLock一章已经讲过","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"AQS","slug":"AQS","permalink":"https//raylax.github.io/tags/AQS/"}]},{"title":"Java并发之AQS相关代码分析-ReentrantLock","slug":"java/aqs-reentrant-lock","date":"2021-01-12T06:17:28.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/aqs-reentrant-lock.html","link":"","permalink":"https//raylax.github.io/post/java/aqs-reentrant-lock.html","excerpt":"","text":"概述Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization.AQS类是了一个实现了阻塞锁的抽象队列同步器，是ReentrantLock、Semaphore、CountDownLatch的基础内部维护一个state状态值和一个FIFO队列内部变量123456789101112// 共享资源private volatile int state;// 获取状态protected final int getState();// 设置状态protected final void setState(int newState);// CAS设置状态protected final boolean compareAndSetState(int expect, int update);// FIFO对列头private transient volatile Node head;// FIFO对列尾private transient volatile Node tail;详解ReentrantLock是依赖AQS实现的一个可重入锁，我们通过分析ReentrantLock工作流程来分析AQS实现ReentrantLock中实现了公平和非公平两种形似，暂且只分析公平锁locklock方法直接调用AQS#acquire(int arg)方法1234567public final void acquire(int arg) &#123; // 如果获取到资源直接返回 if (!tryAcquire(arg) &amp;&amp; // 如果获取资源失败进入等待对列 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;tryAcquiretryAcquire方法由子类ReentrantLock.FairSync类实现123456789101112131415161718192021222324252627282930protected final boolean tryAcquire(int acquires) &#123; // 获取当前线程 final Thread current = Thread.currentThread(); // 获取资源 int c = getState(); // 如果状态是未锁定 if (c == 0) &#123; // 如果不需要排队等待则CAS设置state值 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; // 设置独占线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果资源已经锁定并且独占线程是当前线程 else if (current == getExclusiveOwnerThread()) &#123; // 增加state值 int nextc = c + acquires; // 判断是否溢出 if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); // 设置状态值 // 只有独占的同一个线程才能进入这个分支，所以这里无需使用CAS setState(nextc); return true; &#125; // 如果上述条件都不符合说明获取失败 return false;&#125;hasQueuedPredecessors123456789101112// 判断队列中是否有正在等待的public final boolean hasQueuedPredecessors() &#123; // 根据enq方法可知，如果head和tail二者只有一个为null只有可能是head不为null，tail为null Node t = tail; Node h = head; Node s; // h == t // h == t == null 未初始化过 // h == t != null 对列中只有一个等待者 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125;addWaiter123456789101112131415161718// 加入等待对列private Node addWaiter(Node mode) &#123; // 创建节点 Node node = new Node(Thread.currentThread(), mode); // 如果对列尾不为null，说明已经初始化过 Node pred = tail; if (pred != null) &#123; node.prev = pred; // 设置新节点为尾节点 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 如果没有初始化或者设置失败则进入自旋 enq(node); return node;&#125;enq1234567891011121314151617private Node enq(final Node node) &#123; // 自旋 for (;;) &#123; Node t = tail; if (t == null) &#123; // 初始化 if (compareAndSetHead(new Node())) // 如果此时发生并发则head不为null，tail为null tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125;acquireQueued123456789101112131415161718192021222324252627282930// 等待获取final boolean acquireQueued(final Node node, int arg) &#123; // 是否失败 boolean failed = true; try &#123; // 是否中断 boolean interrupted = false; for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); // 如果前驱节点是头节点则尝试获取 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 如果获取成功则将当前节点设置成头节点 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 判断是否需要挂起 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // 挂起当前线程 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; // 如果失败取消获取 if (failed) cancelAcquire(node); &#125;&#125;shouldParkAfterFailedAcquire1234567891011121314151617181920private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 前驱节点状态 0初始状态 小于0表示节点有效 大于0表示已取消 int ws = pred.waitStatus; // 如果waitStatus已经设置好了直接返回 if (ws == Node.SIGNAL) return true; // 如果前驱节状态无效 if (ws &gt; 0) &#123; // 依次向前查找有效节点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); // 设置前驱节点 pred.next = node; &#125; else &#123; // 设置waitStatus信号量 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;cancelAcquire123456789101112131415161718192021222324252627282930313233343536373839private void cancelAcquire(Node node) &#123; // 如果节点已经不存在，直接忽略 if (node == null) return; // 清除线程 node.thread = null; // 前驱节点 Node pred = node.prev; // 循环向前寻找有效节点 while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // 前驱节点的下一个节点 Node predNext = pred.next; // 设置节点为无效状态 node.waitStatus = Node.CANCELLED; // 如果当前节点是尾节点，则直接设置尾节点为当前节点前第一个有效节点 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; // 设置前驱节点的next为null compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; // 前驱节点不是头节点 if (pred != head &amp;&amp; // 如果前驱节点等于SIGNAL或者可以设置为SIGNAL，并且前驱节点的线程不是null ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; // 将当前节点的后驱节点设置为前驱节点的后驱节点 Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; // 如果前驱节点是头节点则唤醒后驱节点 unparkSuccessor(node); &#125; node.next = node; &#125;&#125;unparkSuccessor123456789101112131415161718192021// 唤醒节点的后驱节点private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 如果是正常状态则设置为初始状态 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 取后驱节点 Node s = node.next; // 如果后驱节点不是null并且后驱节点状态无效 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从尾部向前遍历有效节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 如果节点存在，唤醒节点 if (s != null) LockSupport.unpark(s.thread);&#125;unlocklock方法直接调用AQS#release(int arg)方法123456789101112public final boolean release(int arg) &#123; // 尝试释放 if (tryRelease(arg)) &#123; Node h = head; // 如果释放成功并且waitStatus不是初始状态 if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒后驱及节点 unparkSuccessor(h); return true; &#125; return false;&#125;tryRelease12345678910111213141516protected final boolean tryRelease(int releases) &#123; // 更后的state int c = getState() - releases; // 如果当前线程不是锁的拥有者，直接抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; // 清除独占 setExclusiveOwnerThread(null); &#125; // 设置新的state setState(c); return free;&#125;非公平模式上面讲了公平模式ReentrantLock也可以设置为非公平模式，主要区别在获取时并不判断当前线程是否是等待队列头1234567891011121314151617181920212223242526final boolean nonfairTryAcquire(int acquires) &#123; // 当前线程 final Thread current = Thread.currentThread(); // 当前状态 int c = getState(); // 如果未锁定状态 if (c == 0) &#123; // CAS设置状态 if (compareAndSetState(0, acquires)) &#123; // 设置独占线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果独占线程是当前线程，增加状态 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; // 判断溢出 if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); // 设置状态 setState(nextc); return true; &#125; return false;&#125;","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"AQS","slug":"AQS","permalink":"https//raylax.github.io/tags/AQS/"}]},{"title":"jvm命令行参数","slug":"jvm-command-argments","date":"2019-06-05T01:49:03.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/jvm-command-argments.html","link":"","permalink":"https//raylax.github.io/post/jvm-command-argments.html","excerpt":"","text":"jvm命令行参数标准参数标准参数以-开头，所有jvm都实现了该参数的功能-jar指定运行一个jar包，jar包中manifest文件中必须指定Main-class-cp指定classpath路径-Dproperty=value设置系统属性键值对，使用System.getProperty(&quot;property&quot;)可以获得value-verbose打印jvm载入类的相关信息-verbose:gc打印gc信息-verbose:jni打印native方法调用信息非标准参数非标准参数以-X开头，默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足-Xms-Xms1g 指定jvm初始内存为1g，避免频繁扩容-Xmx-Xmx1g 指定jvm最大可用内存为1g-Xmn-Xmn1g 指定年轻代大小为1g，整个堆 = 年轻代 + 年老代 + 持久代，增加年轻代容量会缩小年老代容量-Xss-Xss1m 设置线程堆栈大小，默认1m。增加此值会减少可创建的线程数量，反而能增加可创建线程数量。可创建线程数量也受操作系统限制-Xloggc-Xloggc:gc.log 将gc日志记录到gc.log中-Xprof跟踪正运行的程序，并将跟踪数据在标准输出输出非Stable参数非Stable参数以-XX开头-XX:PermSize指非堆内存初始大小-XX:MaxPermSize指对非堆内存上限-XX:-UseSerialGC使用串行GC-XX:-UseParallelGC使用并行GC-XX:-UseConcMarkSweepGC对老年代使用CMSConcurrent Mark And Sweep GC参数描述-XX:LargePageSizeInBytes=4m设置用于Java堆的大页面尺寸-XX:MaxHeapFreeRatio=70GC后java堆中空闲量占的最大比例-XX:MaxNewSize=size新生成对象能占用内存的最大值-XX:MaxPermSize=64m老生代对象能占用内存的最大值-XX:MinHeapFreeRatio=40GC后java堆中空闲量占的最小比例-XX:NewRatio=2新生代内存容量与老生代内存容量的比例-XX:NewSize=2.125m新生代对象生成时占用内存的默认值-XX:ReservedCodeCacheSize=32m保留代码占用的内存容量-XX:ThreadStackSize=512设置线程栈大小，若为0则使用系统默认值-XX:+UseLargePages使用大页面内存-XX:-CITime打印消耗在JIT编译的时间-XX:ErrorFile=./hs_err_pid.log保存错误日志或者数据到文件中-XX:-ExtendedDTraceProbes开启solaris特有的dtrace探针-XX:HeapDumpPath=./java_pid.hprof指定导出堆信息时的路径或文件名-XX:-HeapDumpOnOutOfMemoryError当首次遭遇OOM时导出此时堆中相关信息-XX:OnError=”;“出现致命ERROR之后运行自定义命令-XX:OnOutOfMemoryError=”;“当首次遭遇OOM时执行自定义命令-XX:-PrintClassHistogram遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同-XX:-PrintConcurrentLocks遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同-XX:-PrintCommandLineFlags打印在命令行中出现过的标记-XX:-PrintCompilation当一个方法被编译时打印相关信息-XX:-PrintGC每次GC时打印相关信息-XX:-PrintGC Details每次GC时打印详细信息-XX:-PrintGCTimeStamps打印每次GC的时间戳-XX:-TraceClassLoading跟踪类的加载信息-XX:-TraceClassLoadingPreorder跟踪被引用到的所有类的加载信息-XX:-TraceClassResolution跟踪常量池-XX:-TraceClassUnloading跟踪类的卸载信息-XX:-TraceLoaderConstraints跟踪类加载器约束的相关信息","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https//raylax.github.io/tags/jvm/"}]},{"title":"linux快捷键","slug":"linux-shortcut-keys","date":"2019-05-15T13:33:43.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/linux-shortcut-keys.html","link":"","permalink":"https//raylax.github.io/post/linux-shortcut-keys.html","excerpt":"","text":"1ctrl + u删除从开头到光标处的文本1ctrl + k删除光标到结尾处的文本1ctrl + a光标移动到命令行头1ctrl + e光标移动到命令行尾1alt + f向前移动一个单词1ctrl + w删除一个单词","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https//raylax.github.io/tags/linux/"},{"name":"技巧","slug":"技巧","permalink":"https//raylax.github.io/tags/技巧/"}]},{"title":"MySQL-schema与数据类型优化","slug":"mysql-schema-data-type","date":"2019-03-16T13:01:30.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/mysql-schema-data-type.html","link":"","permalink":"https//raylax.github.io/post/mysql-schema-data-type.html","excerpt":"","text":"数据类型整数名称占用空间(bit)范围（有符号）范围（无符号）tinyint8-128 - 1270 - 255smallint16-32,768 - 32,7670 - 65,535mediumint24-8,388,608 - 8,388,6070 - 16,777,215int32-2,147,483,648 - 2,147,483,6470 - 4,294,967,295bigint64-9,233,372,036,854,775,808 - 9,223,372,036,854,775,8070 - 18,446,744,073,709,551,615有符号范围为$(-2^{n-1}\\sim2^{n-1}-1)$，无符号范围为$(0\\sim2^{n}-1)$整数类型可选unsinged属性，表示不能为负，该属性可以使正数范围提高一倍有符号和无符号使用同样的存储空间，并且具有相同的性能MySQL可以为整数类型指定宽度，例如int(8)。实际上对大多数应用并没有意义，它并不会限制类型的范围，只是规定了一些交互工具（MySQL命令行客户端）来显示字符个数的。对于存储计算来说int(1)和int(10)是一样的实数MySQL支持实数类型为float、double、decimalfloat为单精度浮点类型，使用32字节来储存，double为双精度浮点型，使用64字节来储存上述两种类型为非精确类型MySQL提供精确类型decimal，decimal类型再可以指定decimal(m,n)其中m为总长度n为小数长度，其占用空间为m+1因为decimal计算需要额外的开销，所以非精确小数计算使用float、double。精确计算则使用int类型乘小数点后$10^n$来使用例如123.456需要精确3位，则使用int类型123456来储存，使用时直接除1000即可字符串字符串分定长字符串char和非定长字符串varcharvarchar为可变长度字符串它的优势在于仅适用必要的空间来存储数据，但是由于可变长度更新时会比原来长，则需要额外的扩容或更换存储位置。它适合用于平均长度与最大长度差距很大的场景char为定长字符串，char以给定长度分配足够空间，如果需要保存的数据远远小于定义的长度则会造成空间浪费。他适合储存较短的字符串，因为定长所以不会产生内存碎片，性能高于varchar如何储存取决于存储引擎的实现，并非所有的引擎都会按照此方式处理，以上为通常处理方式数据类型的选择更小更好尽量选择适合业务范围的数据类型。更小的数据类型通常意味着占用更少的磁盘、内存和CPU缓存，处理时需要的占用的CPU周期更短。字段扩容对数据库来说是一个繁重的操作，尽量避免线上对字段进行扩容简单就好复杂的数据类势必会占用更长的CPU周期，所以根据业务需求来选择一个相对简单的数据结构是必要的。对于时间等复杂类型应选用内建数据结构来存储，而非使用字符串来存储避免NULL值如果查询中包含了可为NULL的列会使得索引、索引统计和值得比较变得更加复杂。当可为NULL的列被索引肯能需要更多的空间来索引，所以索引列尽量为非NULL列直接将可为NULL的列改为NOT NULL可能并不能对性能带来大的提升","categories":[{"name":"database","slug":"database","permalink":"https//raylax.github.io/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https//raylax.github.io/tags/mysql/"}]},{"title":"Actor学习笔记day3-作用及消息传递","slug":"actor-learning-notes-day3","date":"2019-02-13T10:36:49.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/actor-learning-notes-day3.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day3.html","excerpt":"","text":"Actor模型的作用Actor系统可以帮助你同时利用多个处理器的核心。为了使指定的Actor对象能够对他通过并发方式收到的消息做出回应，每个核心都会被充分利用。调度器通常被用于将线程池中的线程分配给缓存了消息的Actor对象。在繁忙的系统中消息会不断地进入Actor对象的消息缓存中，调度器会不停的为线程分配工作。一直以无阻塞的方式使用线程，可以获得理想的、高效的并发处理系统。Actor对象的消息传递消息通道消息通道指消息生产者和消息消费者的通信方式，但这种通信方式不会使消息生产者和消息消费者之间有任何联系。在使用Actor模型中，从逻辑上将消息通道就是Actor对象的消息缓存，是一种先入先出的队列。消息消息是构成基于消息系统的基本单位管道和过滤器在使用Actor模型时，使用管道和过滤器能够更从容、更轻松的解决问题消息路由器Actor系统中会使用各种消息路由，其中包括有状态和无状态路由、基于环境和基于上下文的路由、回环路由和基于内容路由消息译码器当消息进入和被送出系统时会进行各种转换，当与其他系统进行整合时很可能需要消息译码器消息端点端点并不是什么特殊的事物，他们仅仅是单个Actor对象","categories":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/categories/actor/"}],"tags":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/tags/actor/"},{"name":"scala","slug":"scala","permalink":"https//raylax.github.io/tags/scala/"},{"name":"akka","slug":"akka","permalink":"https//raylax.github.io/tags/akka/"}]},{"title":"Actor学习笔记day2-akka框架","slug":"actor-learning-notes-day2","date":"2019-02-12T08:49:12.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/actor-learning-notes-day2.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day2.html","excerpt":"","text":"使用akka框架环境 scala sbtscala是一种运行在jvm平台的一门多范式的编程语言sbt是简单构建工具(Simple build tool)的缩写，可以从官网获取akka actor是typesafe(lightbend前身)公司出品的一个Actor框架创建akka-demo文件夹，创建build.sbt并添加以下代码12345678name := \"akka-demo\"version := \"0.1\"scalaVersion := \"2.12.8\"lazy val akkaVersion = \"2.5.20\"libraryDependencies ++= Seq( \"com.typesafe.akka\" %% \"akka-actor\" % akkaVersion, \"com.typesafe.akka\" %% \"akka-testkit\" % akkaVersion,)执行sbt命令等待完成编写程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.inurl.akkaimport akka.actor.&#123;Actor, ActorLogging, ActorRef, ActorSystem, Props&#125;/** * @author raylax */class Greeter(message: String, printerActor: ActorRef) extends Actor &#123; import Greeter._ import Printer._ var greeting = \"\" def receive = &#123; // 保存greeting case WhoToGreet(who) =&gt; greeting = message + \", \" + who // 向printerActor发送Greeting消息 case Greet =&gt; printerActor ! Greeting(greeting) &#125;&#125;object Greeter &#123; def props(message: String, printerActor: ActorRef): Props = Props(new Greeter(message, printerActor)) final case class WhoToGreet(who: String) case object Greet&#125;class Printer extends Actor with ActorLogging &#123; import Printer._ def receive = &#123; // 打印greeting case Greeting(greeting) =&gt; log.info(\"Greeting received (from \" + sender() + \"): \" + greeting) &#125;&#125;object Printer &#123; def props: Props = Props[Printer] final case class Greeting(greeting: String)&#125;object ActorDemo extends App &#123; import Greeter._ // 创建Actor系统 val system: ActorSystem = ActorSystem(\"helloAkka\") // 创建子Actor对象 val printer: ActorRef = system.actorOf(Printer.props, \"printerActor\") val howdyGreeter: ActorRef = system.actorOf(Greeter.props(\"Howdy\", printer), \"howdyGreeter\") val helloGreeter: ActorRef = system.actorOf(Greeter.props(\"Hello\", printer), \"helloGreeter\") val goodDayGreeter: ActorRef = system.actorOf(Greeter.props(\"Good day\", printer), \"goodDayGreeter\") // 发送消息 howdyGreeter ! WhoToGreet(\"Akka\") howdyGreeter ! Greet howdyGreeter ! WhoToGreet(\"Lightbend\") howdyGreeter ! Greet helloGreeter ! WhoToGreet(\"Scala\") helloGreeter ! Greet goodDayGreeter ! WhoToGreet(\"Play\") goodDayGreeter ! Greet&#125;执行程序输出内容1234[INFO] [02/12/2019 17:03:28.281] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Akka[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/helloGreeter#-140442030]): Hello, Scala[INFO] [02/12/2019 17:03:28.293] [helloAkka-akka.actor.default-dispatcher-2] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#-1189614707]): Howdy, Lightbend[INFO] [02/12/2019 17:03:28.297] [helloAkka-akka.actor.default-dispatcher-7] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/goodDayGreeter#1061792007]): Good day, Play","categories":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/categories/actor/"}],"tags":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/tags/actor/"},{"name":"scala","slug":"scala","permalink":"https//raylax.github.io/tags/scala/"},{"name":"akka","slug":"akka","permalink":"https//raylax.github.io/tags/akka/"}]},{"title":"Actor学习笔记day1-概述","slug":"actor-learning-notes-day1","date":"2019-01-31T13:10:34.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/actor-learning-notes-day1.html","link":"","permalink":"https//raylax.github.io/post/actor-learning-notes-day1.html","excerpt":"","text":"概述Actor模型是一种用于处理并发计算的数学模型，他对Actor对象用作并发计算的通用基元。他会对收到的消息做出处理，并且可以做以下事情：向其他Actor对象发送一定数量的消息创建一定数量的新Actor对象设定对下一跳消息的处理方式这些操作并没有先后顺序，并且可以通过并行的方式执行他们在一个Actor系统中，所有的事物都是Actor对象，只有多个Actor对象组成的系统叫做Actor系统，单个Actor对象并不能称为Actor系统。特点通过异步的方式传递消息如果Actor对象A1要给Actor对象A2发送消息M1，就必须知道A2的地址，那么A1就直接可以向A2发送消息。实际上A2会使用独立于A1的线程接受处理消息，A1就要以异步的方式发送消息给A2，实际上消息传输中间有一个中间对象(消息缓存单元)负责消息分发，即便如此我们还是称之为异步直接传输状态机Actor支持有限状态机。当Actor对象转换为某个预设状态时，他就能改变对未来接收到的消息的处理模式。通过改变成为另一种消息处理器Actor对象就成了一种有限状态机*无共享**一个Actor对象不会与其他Actor对象共享组件可变状态无锁处理并发因为Actor对象不会共享其可变状态，而且他们在同一时刻仅会接受处理一条消息，所以在对消息做出回应前Actor对象永远都不会尝试锁定他们的状态并行性并行性是通过将单个复杂的处理过程拆分成较小的任务以并发处理的方式执行他们实现的系统性单个Actor对象是不具备并行性的。Actor对象是非常轻量的，因此在在单个系统中创建多个Actor对象是推荐的处理方式。任何问题都可以通过添加Actor对象来解决","categories":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/categories/actor/"}],"tags":[{"name":"actor","slug":"actor","permalink":"https//raylax.github.io/tags/actor/"},{"name":"scala","slug":"scala","permalink":"https//raylax.github.io/tags/scala/"},{"name":"akka","slug":"akka","permalink":"https//raylax.github.io/tags/akka/"}]},{"title":"java-String/StringBuilder/StringBuffer区别","slug":"java/string-stringbuilder-stringbuffer","date":"2019-01-28T14:29:04.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/string-stringbuilder-stringbuffer.html","link":"","permalink":"https//raylax.github.io/post/java/string-stringbuilder-stringbuffer.html","excerpt":"","text":"String12345678/* * java.lang.String部分代码 */public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125;首先String是一个final修饰不可继承的类，内部使用final修饰的char[]来保存数据，String是不可变的123String str = \"123\";System.out.println((str + \"456\") == str);// output : false每次对String拼接都会创建一个新String对象AbstractStringBuilderAbstractStringBuilder是一个抽象类，是StringBuilder和StringBuffer的父类，二者大部分操作都是基于此类实现的123456789101112131415/* * java.lang.AbstractStringBuilder部分代码 */abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count;&#125;AbstractStringBuilder是一个可变的字符串类，内部使用char[]来保存数据，count用来记录value已用长度。每次append操作都会向value中添加数据，若数组容量不够则进行扩容，扩容后容量是原容量的2倍append操作并不会创建新对象，而是在原有对象上进行修改，所以AbstractStringBuilder是可变的123456StringBuilder bd = new StringBuilder(\"123\");System.out.println(bd.append(\"345\") == bd);// output : trueStringBuffer bf = new StringBuffer(\"123\");System.out.println(bf.append(\"345\") == bf);// output : trueStringBuilderStringBuilder继承AbstractStringBuilder类所有方法均调用父类实现StringBufferStringBuilder继承AbstractStringBuilder类所有方法均调用父类实现所有方法均使用synchronized关键字修饰，所以StringBuffer是线程安全的结语实际上在编译期优化了的string+操作的运行效率并非低于使用其他两个类因为许多编译器会将此操作优化为builder.append的形式理论上执行效率 StringBuilder &gt; StringBuffer &gt; String","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]},{"title":"java集合-List类","slug":"java/collection-list","date":"2019-01-27T14:47:17.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/collection-list.html","link":"","permalink":"https//raylax.github.io/post/java/collection-list.html","excerpt":"","text":"ArrayListArrayList内部使用数组实现内部关键变量12345678910// 默认初始容量private static final int DEFAULT_CAPACITY = 10;// 空列表常量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 默认空列表常量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 存放数据数组transient Object[] elementData;// 列表大小(列表大小并不总是等于elementData.length，因为elementData会有冗余)private int size;构造方法1234567891011121314151617181920/* * 创建一个初始容量为0空列表 * 使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA填充elementData */public ArrayList();/* * 如果initialCapacity大于0，创建一个初始容量为initialCapacity的列表 * 为elementData创建一个大小为initialCapacity的数组 * * 如果initialCapacity等于0，创建一个初始容量为0的数组 * 使用EMPTY_ELEMENTDATA填充elementData * * 如果initialCapacity小于0，抛出IllegalArgumentException */public ArrayList(int initialCapacity);/* * 传入一个集合如果c长度不为0，将c的数组复制到elementData * c的长度赋值到size */public ArrayList(Collection&lt;? extends E&gt; c);扩容机制如果使用无参构造创建List，在第一次扩容时如果如果期望容量小于10则会将容量设置为10后续扩容newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)也就是说每次扩容后大小是原数组大小的1.5倍RandomAccessArrayList实现了RandomAccess接口，实际上RandomAccess内部并无需要实现的方法此接口只是为了标识该列表支持随机访问，也就是支持按下标访问主要用于Collections.binarySearch等方法区分查找方式LinkedListLinkedList内部使用双向链表实现内部关键变量123456789101112131415// 列表大小transient int size = 0;// 第一个节点指针transient Node&lt;E&gt; first;// 最后一个节点指针transient Node&lt;E&gt; last;// 内部Nodeclass Node&lt;E&gt; &#123; // 实际对象 E item; // 指向上一个对象 Node&lt;E&gt; next; // 指向下一个对象 Node&lt;E&gt; prev;&#125;运行原理向头部添加对象会创建一个next指向first的新节点，将first指向新节点向指定位置添加对象创建一个prev指向该位置元素的prev，last指向该对象的新节点，原对象prev指向新节点向尾部添加对象会创建一个prev指向last的新节点，将last指向新节点DequeLinkedList实现了Deque接口，说明LinkedList实现了可以当做一个双向队列使用，LinkedList使用的数据结构完美的支持双向队列时间复杂度对比操作\\类型ArrayListLinkedList获取指定位置对象$O(1)$$O(n)$向头部添加对象$O(n)$$O(1)$向指定位置添加对象$O(n)$$O(n)$向尾部添加对象$O(1)$$O(1)$删除头部对象$O(n)$$O(1)$删除指定位置对象$O(n)$$O(n)$删除尾部对象$O(1)$$O(1)$Vector与ArrayList区别Vector与ArrayList实现原理基本类似主要区别在于，Vector每个方法都是加了synchronized同步的，是线程安全的而ArrayList是非线程安全的","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"集合","slug":"集合","permalink":"https//raylax.github.io/tags/集合/"}]},{"title":"java并发-synchronized关键字&CAS锁","slug":"java/concurrent-synchronized-cas-lock","date":"2019-01-26T11:08:29.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/concurrent-synchronized-cas-lock.html","link":"","permalink":"https//raylax.github.io/post/java/concurrent-synchronized-cas-lock.html","excerpt":"","text":"引言java中提供了synchronized关键字和java.util.concurrent.locks包下的相关类来进行线程同步synchronized关键字在1.6之前synchronized是一个重量级锁，此同步方式同步成本非常高，因为阻塞线程会引起用户态和内核态之间切换。此后jvm对此同步方式进行了许多优化(偏向锁、轻量级锁)可以放心使用，而且因为是java关键字所以也可以享受以后的优化并且不需要更改代码修饰锁对象静态方法当前类对象(class)实例方法当前实例(this)修饰代码块指定变量synchronized锁膨胀过程 [偏向锁] -&gt; [轻量级锁] -&gt; [重量级锁]偏向锁偏向锁会在第一次进行同步访问时的将访问线程的线程ID使用CAS记录到互斥变量的Mark word。以后每次访问则检查访问线程的ID是否等于Mark word中记录的线程ID，如果等于则可以无锁同步。如果线程ID不相同则说明有其他线程竞争，此时偏向锁会膨胀成轻量级锁适用场景：自始至终仅有同一线程访问优点：可以实现无锁同步缺点：如果很明显有其他线程竞争则很快将膨胀成轻量级锁轻量级锁加锁：为访问线程创建Lock record，将锁对象的Mark word复制到Lock record称为Displaced mark word，尝试使用CAS将Mark word指向Displaced mark word，如果成功则获取锁成功，否则循环重试解锁：使用Displaced mark word替换原对象的Mark word轻量级锁会在重试次数过多时膨胀成重量级锁适用场景：线程竞争少，非耗时操作优点：可以避免线程阻塞造成的造成的用户态和内核态切换成本缺点：如果进行耗时操作则会循环获取锁占用CPU资源重量级锁重量级锁会在利用操作系统底层创建互斥量实现，同步时会造成内核态切换适用场景：线程竞争激烈，耗时操作优点：线程直接阻塞无CPU资源占用缺点：线程阻塞，阻塞和唤醒线程耗时可能会超过代码本身执行时间，性能可能低于轻量级锁ReentrantLock锁ReentrantLock分为公平锁和非公平锁，内部使用CAS方式实现具体原理类似于轻量级锁对比synchronizedjava关键字，易用无需改代码享受jdk优化ReentrantLockjava类，加锁解锁都是实例方法，可以更灵活的控制提供Condition可以灵活的控制要唤醒的线程可以实现公平锁可以中断等待","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https//raylax.github.io/tags/并发/"}]},{"title":"java并发-volatile关键字","slug":"java/concurrent-volatile-keyword","date":"2019-01-24T06:16:31.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/concurrent-volatile-keyword.html","link":"","permalink":"https//raylax.github.io/post/java/concurrent-volatile-keyword.html","excerpt":"","text":"引言前一篇文章讲了java内存模型相关概念，线程在工作的时候会从主内存中复制数据到工作内存中进行操作，这样多线程情况下就会出现数据一致性问题，使用volatile关键字则可以避免此问题。作用如果使用volatile关键字修饰一个类的(静态)成员变量，则有两种作用确保了多线程对此变量的可见性每次获取变量会强制从主内存获取，每次修改变量后会立即刷新到主内存禁止进行指令重排(java虚拟为了优化执行效率会进行指令重排，暂不详细说明)volatile可以保证原子性么volatile仅能确保每次获取的数据都是最新的数据，并不能保证原子性12345678910111213141516171819202122public class VolatileTest &#123; private volatile int count = 0; public static void main(String[] args) throws Exception &#123; VolatileTest v = new VolatileTest(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(10); // 创建10个线程 for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(() -&gt; &#123; // 每个线程增加10000 for (int j = 0; j&lt; 10000; j++) &#123; v.count++; &#125; &#125;)); &#125; // 启动 threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(v.count); &#125;&#125;结果应该是100000，实际上这段代码运行结果并不是100000，因为count++操作不是一个原子操作，++操作会先获取count变量然后对其加一刷新到主内存多线程情况下可能多个线程同时获取了该变量对其操作然后刷新到主内存。例如数据是5，2条线程同时获取了该变量对其+1，同时将6刷新到主内存，这时主内存的数据是6但我们期望的是7要解决这个问题可以用synchronized和ReentrantLock对要操作的数据加同步锁解决此问题synchronized解决方式synchronized方式通过java内置字节码指令monitorenter和monitorexit实现的123456789101112131415161718192021222324252627public class VolatileTest &#123; private volatile int count = 0; private volatile Object countMutex = new Object(); public static void main(String[] args) throws Exception &#123; VolatileTest v = new VolatileTest(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(10); // 创建10个线程 for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(() -&gt; &#123; // 每个线程增加10000 for (int j = 0; j&lt; 10000; j++) &#123; // 加锁 synchronized (v.countMutex) &#123; v.count++; &#125; &#125; &#125;)); &#125; // 启动 threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(v.count); &#125;&#125;`ReentrantLock解决方式ReentrantLock方式通过CAS方式实现123456789101112131415161718192021222324252627public class VolatileTest &#123; private volatile int count = 0; public static void main(String[] args) throws Exception &#123; VolatileTest v = new VolatileTest(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(10); ReentrantLock lock = new ReentrantLock(); // 创建10个线程 for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(() -&gt; &#123; // 每个线程增加10000 for (int j = 0; j&lt; 10000; j++) &#123; // 加锁 lock.lock(); v.count++; lock.unlock(); &#125; &#125;)); &#125; // 启动 threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(v.count); &#125;&#125;`","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https//raylax.github.io/tags/并发/"}]},{"title":"java-内存模型","slug":"java/memory-model","date":"2019-01-23T02:20:33.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/memory-model.html","link":"","permalink":"https//raylax.github.io/post/java/memory-model.html","excerpt":"","text":"引言计算机程序每条指令都由CPU执行，执行过程中会对数据进行操作，程序运行时的临时数据都储存在内存中。但是CPU执行指令的速度远远大于内存读取/写入速度，如果每次操作都需要对内存进行一次操作会大幅度降低CPU运行速度，所以CPU引入高速缓存(L1/L2/L3)来提高读写速度，如果需要对某条数据进行操作，CPU会从内存中复制数据到高速缓存中，然后对其进行一系列操作操作，结束后刷新到内存里。引入高速缓存很好的解决了CPU执行的效率问题，但引发了一致性问题，即在多核心状态下，每个核心都有自己的高速缓存，无法保证同一数据不同核心下的高速缓存是一致的。CPU通过缓存一致性协议来解决了这个问题，例如Intel MESI协议，这里不做过多说明。Java虚拟机中定义了一种类似的Java内存模型，来屏蔽各硬件平台和操作系统之间的差异以及提高程序运行效率。内存模型堆内存共享区域java虚拟机管理的最大内存区域，几乎所有的对象都会在此区域分配。在需要时自行扩展，可以通过-Xmx|-Xms来控制大小，当此区域内存回收后无法为新对象分配空间且无法扩展，则会抛出OutOfMemoryError异常方法区共享区域用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。栈内存线程私有用于存储局部变量表、操作栈、动态链接、方法出口等信息。该区域内存用尽会抛出StackOverFlow异常，常见于递归操作，可以通过-Xss参数来调解栈内存大小本地方法区线程私有为Native方法服务，规范中并未明确定义数据结构和使用方式程序计数器线程私有用于记录当前执行的字节码的行号，java虚拟机利用计数器来实现循环、跳转以及线程切换恢复执行。使用nio分配堆外内存暂不说明运行机制所有对象都储存在主内存中，不包括局部变量和方法参数，局部变量与方法参数是线程私有的。每个线程还有自己的工作内存，类似于CPU的高速缓存。当每个线程工作时会从主内存中拷贝一份数据到工作内存，在工作内存进行操作，操作完成后才会刷新到主内存中。","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]},{"title":"Spring-bean管理","slug":"java/spring-bean","date":"2019-01-22T10:01:56.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/spring-bean.html","link":"","permalink":"https//raylax.github.io/post/java/spring-bean.html","excerpt":"","text":"前言Spring中所有的bean都由IoC容器管理，IoC容器负责创建/销毁bean，Spring中的IoC容器即BeanFactory，BeanFactory为一个接口，Srping中所有的ApplicationContext都实现了此接口。作用域Spring中定义了4种bean的作用域以适应不同业务场景作用域描述singleton单例方式存在，只创建一个实例，每次获取都返回该实例(默认)prototype每次获取都创建一个新实例request同一请求下每次获取实例都返回同一个实例(仅限于WebApplicationContext)session同一会话下每次获取实例都返回同一个实例(仅限于WebApplicationContext)其中后两者是只有在web环境下才生效的，基于WebApplicationContext生命周期singleton容器时启动创建，随容器关闭而销毁，可以设置@Lazy注解使其在第一次获取时创建prototype该作用域的实例Spring并不负责管理生命周期request随每个请求创建/销毁session随每个会话创建/销毁生命周期监控Spring管理的bean的生命周期可以使用一系列接口/注解来监控bean的生命周期实例级监控InitializingBean#afterPropertiesSet在bean初始化成功后调用DiposableBean#destroy在bean销毁前调用@PostConstruct该注解修饰的方法会在bean创建后调用@PreDestroy该注解修饰的方法会在bean销毁前调用@PostConstruct修饰的方法先于InitializingBean#afterPropertiesSet执行@PreDestroy修饰的方法先于DiposableBean#destroy执行容器级监控BeanPostProcessor#postProcessBeforeInitialization方法会在bean初始化前调用，先于@PostConstruct|InitializingBean#afterPropertiesSet执行BeanPostProcessor#postProcessAfterInitialization方法会在bean初始化前调用，后于@PostConstruct|InitializingBean#afterPropertiesSet执行图片描述上面这张图完整描述了bean的生命周期(图片来源于网络)","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https//raylax.github.io/tags/spring/"}]},{"title":"MySQL-事务隔离级别","slug":"mysql-transaction-isolation","date":"2019-01-21T06:18:25.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/mysql-transaction-isolation.html","link":"","permalink":"https//raylax.github.io/post/mysql-transaction-isolation.html","excerpt":"","text":"事务ACID特性原子性(Atomicity)一个事物内的所有操作视为一个不可分割的操作，事务内所有操要么全执行成功要么全失败例如：一个事务内A给B转账，先从A账户中扣钱，然后向B账户中加对应的钱数，这两次数据库操作要么全成功要么全失败，不能某个操作成功了，其他的失败了一致性(Consistency)一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少(摘自百度)例如：一共有2个账户，这些账户的总余额为100，无论如何进行并发操作最终这2个账户的余额的和必须为100隔离性(Isolation)隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作持久性(Durability)在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚事务隔离级别完全隔离是不现实的，因为完全隔离会使事务串行化，严重影响并发性能，所以引入隔离级别来控制并发访问MySQl支持4中隔离级别隔离级别描述读未提交(read uncommitted)一个事务可以读其他事务未提交的数据读已提交(read committed)一个事务只能读其他事务已提交的数据可重复读(repeatable read)一个事务内多次读同一数据必须一致(MySQL默认隔离级别)串行化(serializable)事务串行化，同一个表同时只能有一个事务进行操作并发引发问题脏读A事务读取了B事务未提交的数据并在此基础上进行操作，结果B事务回滚了，那么A所进行的操作就是有问题的不可重复读不可重复读指同一事务中两次读取的数据不一致，A事务读取了一条数据，B事务修改了数据并且提交了，A事务又读了此条数据结果与上一读取的数据不一致幻读事务A统计了数据量，事务B添加了N条记录，事务B又查了一次，结果两次结果数量不一致隔离级别对应问题隔离级别越往下并发效率越低，可重复读行级锁，串行化表级锁级别\\问题脏读不可重复读幻读读未提交(read uncommitted)xxx读已提交(read committed)√xx可重复读(repeatable read)√√x串行化(serializable)√√√总结只有InnoDB引擎支持事务并且支持行级锁，MyISAM引擎并不支持事务且仅支持表级锁InnoDB适合频繁update业务场景(交易系统)，MyISAM适用于大量select、insert业务场景(日志类系统)处理数据库并发问题并非只能依靠数据来处理，可以结合代码进行合理的加锁，例如依靠外部redis/zookeeper做分布式锁","categories":[{"name":"database","slug":"database","permalink":"https//raylax.github.io/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https//raylax.github.io/tags/mysql/"}]},{"title":"Spring-事物传播方式/机制","slug":"java/spring-transaction","date":"2019-01-20T10:55:03.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/spring-transaction.html","link":"","permalink":"https//raylax.github.io/post/java/spring-transaction.html","excerpt":"","text":"概述Spring在org.springframework.transaction.TransactionDefinition中定义了七中事物传播方式，规定了需要执行事物的方法和事物发生嵌套时如何进行传播传播方式描述PROPAGATION_REQUIRED支持当前事务，如果没有事务则创建一个事务PROPAGATION_SUPPORTS支持当前事务，如果没有事务则已非事务方式执行PROPAGATION_MANDATORY支持当前事务，如果没有事务则抛异常PROPAGATION_REQUIRES_NEW创建新事务，如果已存在事务则挂起PROPAGATION_NOT_SUPPORTED不支持当前事务，如果存在则以非事务方式执行PROPAGATION_NEVER不支持当前事务，如果存在则抛出异常PROPAGATION_NESTED如果当前存在事务则执行嵌套事务，否则以类似PROPAGATION_REQUIRED方式执行详解除了PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED其他都很好理解，主要解释下这两者的区别PROPAGATION_REQUIRES_NEW创建一个独立的”内部”事务，挂起原有事务，此事务与原事务互不依赖1234567891011121314151617181920// UserServiceAImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void addUser(UserEntity user) &#123; logger.info(\"UserServiceAImpl#addUser begin\"); userRepository.save(user); userServiceB.updateUser(user); logger.info(\"UserServiceAImpl#addUser complete\");&#125;// UserServiceBImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void updateUser(UserEntity user) &#123; logger.info(\"UserServiceBImpl#updateUser begin\"); userRepository.save(user); logger.info(\"UserServiceBImpl#updateUser complete\");&#125;// Test.javaUserEntity user = new UserEntity(\"raylax\");userServiceA.addUser(user);截取部分运行日志12345678910111213141516171819202122232425262728293031# 创建事务Creating new transaction with name [UserServiceAImpl.addUser]: PROPAGATION_REQUIRED,ISOLATION_DEFAULTOpened new EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transactionExposing JPA transaction as JDBC [HibernateConnectionHandle@580902cd]# 进入addUser方法UserServiceAImpl#addUser beginFound thread-bound EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transactionParticipating in existing transactionFound thread-bound EntityManager [SessionImpl(254041053&lt;open&gt;)] for JPA transaction# 挂起当前事务Suspending current transaction, creating new transaction with name [UserServiceBImpl.updateUser]# 创建新事务Opened new EntityManager [SessionImpl(40626598&lt;open&gt;)] for JPA transactionExposing JPA transaction as JDBC [HibernateConnectionHandle@4d518c66]# 进入updateUser方法UserServiceBImpl#updateUser beginFound thread-bound EntityManager [SessionImpl(40626598&lt;open&gt;)] for JPA transactionParticipating in existing transaction# 退出updateUser方法UserServiceBImpl#updateUser complete# 提交新事务Initiating transaction commitCommitting JPA transaction on EntityManager [SessionImpl(40626598&lt;open&gt;)]Closing JPA EntityManager [SessionImpl(40626598&lt;open&gt;)] after transaction# 恢复被挂起的事务Resuming suspended transaction after completion of inner transaction# 退出addUser方法UserServiceAImpl#addUser complete# 提交原事务Initiating transaction commitCommitting JPA transaction on EntityManager [SessionImpl(254041053&lt;open&gt;)]PROPAGATION_NESTED如果当前存在事务则执行嵌套事务，否则以类似PROPAGATION_REQUIRED方式执行嵌套事务创建同时会创建一个savepoint如果该事务发生异常会回滚到savepoint嵌套事务会跟随父事务commit/rollbackNESTED需要基于JDBC3.0并且事务支持savepoint1234567891011121314151617181920// UserServiceAImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void addUser(UserEntity user) &#123; logger.info(\"UserServiceAImpl#addUser begin\"); jdbcTemplate.execute(\"insert into t_user values(1, '\" + user.getName() + \"')\"); userServiceB.updateUser(user); logger.info(\"UserServiceAImpl#addUser complete\");&#125;// UserServiceBImpl.java@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)@Overridepublic void updateUser(UserEntity user) &#123; logger.info(\"UserServiceBImpl#updateUser begin\"); jdbcTemplate.update(\"update t_user set name = '\" + user.getName() + \"-updated'\"); logger.info(\"UserServiceBImpl#updateUser complete\");&#125;// Test.javaUserEntity user = new UserEntity(\"raylax\");userServiceA.addUser(user);截取部分运行日志123456789101112131415161718192021# 创建事务Acquired Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] for JDBC transactionSwitching JDBC Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] to manual commit# 进入addUser方法UserServiceAImpl#addUser beginExecuting SQL statement [insert into t_user values(1, &apos;raylax&apos;)]# 创建嵌套事务，创建保存点Creating nested transaction with name [UserServiceBImpl.updateUser]# 进入updateUser方法UserServiceBImpl#updateUser beginExecuting SQL update [update t_user set name = &apos;raylax-updated&apos; where id = null]# 退出updateUser方法UserServiceBImpl#updateUser complete# 释放保存点Releasing transaction savepoint# 退出addUser方法UserServiceAImpl#addUser complete# 提交事务，嵌套事务会跟随提交Initiating transaction commitCommitting JDBC transaction on Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a]Releasing JDBC Connection [HikariProxyConnection@183304529 wrapping ConnectionImpl@400d912a] after transaction注意事项事务默认以PROPAGATION_REQUIRED方式执行事务传播的控制基于AOP，所以只有调用spring管理的实例方法时生效，调用this指向方法不生效例如ClassA调用methodA，methodA中调用了ClassB的methodB此时传播控制才生效如ClassA调用methodA，methodA中调用调用了内部的methodB则会以PROPAGATION_REQUIRED方式执行，传播控制不生效生效示例12345678910// ClassA.javapublic void methodA() &#123; classB.methodB();&#125;// ClassB.javapublic void methodB() &#123;&#125;// Test.javaclassA.methodA();不生效示例123456789// ClassA.javapublic void methodA() &#123; methodB();&#125;public void methodB() &#123; &#125;// Test.javaclassA.methodA();","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https//raylax.github.io/tags/spring/"}]},{"title":"JAVA-JDK和CGLIB动态代理使用","slug":"java/jdk-proxy-cglib-proxy-use","date":"2019-01-20T10:50:33.000Z","updated":"2021-02-22T13:34:51.509Z","comments":true,"path":"post/java/jdk-proxy-cglib-proxy-use.html","link":"","permalink":"https//raylax.github.io/post/java/jdk-proxy-cglib-proxy-use.html","excerpt":"","text":"代理模式代理模式即给某一对象生成一个代理对象，来对原对象进行一些访问控制通过代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部应用场景鉴权、事物、日志、异常处理…静态代理优点：面向接口编程屏蔽内部实现，如需修改实现类直接修改代理类即可缺点：每个代理类只能为一个接口服务，需要为每个接口创建代理。实现类与代理类都实现了相同的接口，如增加一个方法所有代理类都需要进行修改，增加了维护的复杂度1234567891011121314151617181920212223242526272829interface Person &#123; void doAction();&#125;class RealPerson implements Person &#123; @Override public void doAction() &#123; System.out.println(\"do action !\"); &#125;&#125;class ProxyPerson implements Person &#123; private Person person = new RealPerson(); @Override public void doAction() &#123; System.out.println(\"method start\"); try &#123; person.doAction(); System.out.println(\"method complete\"); &#125; catch (Exception e) &#123; System.out.println(\"method error\"); &#125; &#125;&#125;public void call() &#123; Person person = new ProxyPerson(); person.doAction();&#125;JDK动态代理需要用到的类java.lang.reflect.InvocationHandler和java.lang.reflect.ProxyProxy为原对象的代理对象InvocationHandler#invoke方法会在代理对象被调用时调用，可以在此处做处理Proxy#newProxyInstance方法的第二个参数必须为接口，所以JDK动态代理只能为实现了接口的类生成代理123456789101112131415161718192021222324252627282930313233343536373839404142interface Person &#123; void doAction();&#125;class RealPerson implements Person &#123; @Override public void doAction() &#123; System.out.println(\"do action !\"); &#125;&#125;class ProxyClass implements InvocationHandler &#123; private Object realObject; ProxyClass(Object realObject) &#123; this.realObject = realObject; &#125; public Object newProxy() &#123; // 生成代理对象 return Proxy.newProxyInstance( realObject.getClass().getClassLoader(), realObject.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"method start\"); try &#123; // 使用反射调用原对象方法 Object result = method.invoke(realObject, args); System.out.println(\"method complete\"); return result; &#125; catch (Exception e) &#123; System.out.println(\"method error\"); throw e; &#125; &#125;&#125;public void call() &#123; Person person = (Person) new ProxyClass(new RealPerson()).newProxy(); person.doAction();&#125;CGLib动态代理CGLib动态代理底层采用ASM字节码生成框架，使用字节码技术生成代理类，原理是生成目标类的子类。CGLib可以为未实现接口的类生成代理，但无法为final类生成代理123456789101112131415161718192021222324252627282930313233class RealPerson &#123; public void doAction() &#123; System.out.println(\"do action !\"); &#125;&#125;class ProxyClass implements MethodInterceptor &#123; public Object newProxy(Class clazz) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"method start\"); try &#123; // 调用父类方法 Object result = proxy.invokeSuper(obj, args); System.out.println(\"method complete\"); return result; &#125; catch (Exception e) &#123; System.out.println(\"method error\"); throw e; &#125; &#125;&#125;public void call() &#123; RealPerson person = (RealPerson) new ProxyClass().newProxy(RealPerson.class); person.doAction();&#125;","categories":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https//raylax.github.io/tags/java/"}]}]}